/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : cqpTreeWalker.g
 *     -                            On : 2015-04-08 21:27:02
 *     -           for the tree parser : cqpTreeWalkerTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

    // Copyright (c) 1999-2013  Pavel Rychly, Milos Jakubicek

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cqpTreeWalker.hh"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pcqpTreeWalker_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcqpTreeWalker_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pcqpTreeWalker_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pcqpTreeWalker_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   cqpTreeWalkerTokenNames[46+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ANYPOS",
        (pANTLR3_UINT8) "ATTR",
        (pANTLR3_UINT8) "BEGSTRUCT",
        (pANTLR3_UINT8) "BINAND",
        (pANTLR3_UINT8) "BINOR",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "EEQ",
        (pANTLR3_UINT8) "ENDSTRUCT",
        (pANTLR3_UINT8) "EQ",
        (pANTLR3_UINT8) "GEQ",
        (pANTLR3_UINT8) "KW_CCOLL",
        (pANTLR3_UINT8) "KW_CONTAINING",
        (pANTLR3_UINT8) "KW_FREQ",
        (pANTLR3_UINT8) "KW_MEET",
        (pANTLR3_UINT8) "KW_MU",
        (pANTLR3_UINT8) "KW_SWAP",
        (pANTLR3_UINT8) "KW_UNION",
        (pANTLR3_UINT8) "KW_WITHIN",
        (pANTLR3_UINT8) "KW_WS",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "LBRACKET",
        (pANTLR3_UINT8) "LEQ",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "LSTRUCT",
        (pANTLR3_UINT8) "NNUMBER",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPT",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "POSNUM",
        (pANTLR3_UINT8) "QUEST",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "RBRACKET",
        (pANTLR3_UINT8) "REGEXP",
        (pANTLR3_UINT8) "REPOPT",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "RSTRUCT",
        (pANTLR3_UINT8) "SEMI",
        (pANTLR3_UINT8) "SEQ",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "TEQ",
        (pANTLR3_UINT8) "WHOLESTRUCT",
        (pANTLR3_UINT8) "WS_"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 RangeStream *
	prog    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	query    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	within_containing    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	alignedpart    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	globcond    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	structure    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	bigseq    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	seqpart    (pcqpTreeWalker ctx, Corpus &c);
static 
 FastStream *
	labeledpos    (pcqpTreeWalker ctx, Corpus &c);
static 
 RangeStream *
	repeat    (pcqpTreeWalker ctx, Corpus &c);
static 
 FastStream *
	onepos    (pcqpTreeWalker ctx, Corpus &c);
static 
 FastStream *
	muquery    (pcqpTreeWalker ctx, Corpus &c);
static 
 FastStream *
	mupart    (pcqpTreeWalker ctx, Corpus &c);
static void	cqpTreeWalkerFree(pcqpTreeWalker ctx);
static void     cqpTreeWalkerReset (pcqpTreeWalker ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "cqpTreeWalker.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new cqpTreeWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcqpTreeWalker
cqpTreeWalkerNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return cqpTreeWalkerNewSSD(instream, NULL);
}

/** \brief Create a new cqpTreeWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcqpTreeWalker
cqpTreeWalkerNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcqpTreeWalker ctx;	    /* Context structure we will build and return   */

    ctx	= (pcqpTreeWalker) ANTLR3_CALLOC(1, sizeof(cqpTreeWalker));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in cqpTreeWalker.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our cqpTreeWalker interface
     */
    ctx->prog	= prog;
    ctx->query	= query;
    ctx->within_containing	= within_containing;
    ctx->alignedpart	= alignedpart;
    ctx->globcond	= globcond;
    ctx->structure	= structure;
    ctx->bigseq	= bigseq;
    ctx->seqpart	= seqpart;
    ctx->labeledpos	= labeledpos;
    ctx->repeat	= repeat;
    ctx->onepos	= onepos;
    ctx->muquery	= muquery;
    ctx->mupart	= mupart;
    ctx->free			= cqpTreeWalkerFree;
    ctx->reset			= cqpTreeWalkerReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */


        RECOGNIZER->displayRecognitionError = throwEvalQueryException;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = cqpTreeWalkerTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
cqpTreeWalkerReset (pcqpTreeWalker ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 cqpTreeWalkerFree(pcqpTreeWalker ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return cqpTreeWalkerTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_prog70  */
static	ANTLR3_BITWORD FOLLOW_query_in_prog70_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_prog70	= { FOLLOW_query_in_prog70_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_within_containing_in_query86  */
static	ANTLR3_BITWORD FOLLOW_within_containing_in_query86_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_within_containing_in_query86	= { FOLLOW_within_containing_in_query86_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_globcond_in_query94  */
static	ANTLR3_BITWORD FOLLOW_globcond_in_query94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_globcond_in_query94	= { FOLLOW_globcond_in_query94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WITHIN_in_within_containing119  */
static	ANTLR3_BITWORD FOLLOW_KW_WITHIN_in_within_containing119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WITHIN_in_within_containing119	= { FOLLOW_KW_WITHIN_in_within_containing119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing122  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing122_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000820180) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing122	= { FOLLOW_NOT_in_within_containing122_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing130  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing130_bits[]	= { ANTLR3_UINT64_LIT(0x00001000808203A0) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing130	= { FOLLOW_query_in_within_containing130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing146  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing146_bits[]	= { ANTLR3_UINT64_LIT(0x00001000008203A0) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing146	= { FOLLOW_NOT_in_within_containing146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_within_containing174  */
static	ANTLR3_BITWORD FOLLOW_structure_in_within_containing174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_within_containing174	= { FOLLOW_structure_in_within_containing174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing181  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing181	= { FOLLOW_query_in_within_containing181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alignedpart_in_within_containing198  */
static	ANTLR3_BITWORD FOLLOW_alignedpart_in_within_containing198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_alignedpart_in_within_containing198	= { FOLLOW_alignedpart_in_within_containing198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CONTAINING_in_within_containing228  */
static	ANTLR3_BITWORD FOLLOW_KW_CONTAINING_in_within_containing228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CONTAINING_in_within_containing228	= { FOLLOW_KW_CONTAINING_in_within_containing228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing231  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing231_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000820180) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing231	= { FOLLOW_NOT_in_within_containing231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing239  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing239_bits[]	= { ANTLR3_UINT64_LIT(0x00001000808203A0) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing239	= { FOLLOW_query_in_within_containing239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing255  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing255_bits[]	= { ANTLR3_UINT64_LIT(0x00001000008203A0) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing255	= { FOLLOW_NOT_in_within_containing255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_within_containing283  */
static	ANTLR3_BITWORD FOLLOW_structure_in_within_containing283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_within_containing283	= { FOLLOW_structure_in_within_containing283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing290  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing290	= { FOLLOW_query_in_within_containing290_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alignedpart_in_within_containing307  */
static	ANTLR3_BITWORD FOLLOW_alignedpart_in_within_containing307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_alignedpart_in_within_containing307	= { FOLLOW_alignedpart_in_within_containing307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_alignedpart361  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_alignedpart361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_alignedpart361	= { FOLLOW_COLON_in_alignedpart361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_alignedpart365  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_alignedpart365_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_alignedpart365	= { FOLLOW_ATTR_in_alignedpart365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_alignedpart379  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_alignedpart379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_alignedpart379	= { FOLLOW_bigseq_in_alignedpart379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINAND_in_globcond437  */
static	ANTLR3_BITWORD FOLLOW_BINAND_in_globcond437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINAND_in_globcond437	= { FOLLOW_BINAND_in_globcond437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_globcond439  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_globcond439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040800) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_globcond439	= { FOLLOW_bigseq_in_globcond439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_globcond459  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_globcond459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_globcond459	= { FOLLOW_DOT_in_globcond459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond463  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond463_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond463	= { FOLLOW_NUMBER_in_globcond463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond467  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080004000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond467	= { FOLLOW_ATTR_in_globcond467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond491  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond491	= { FOLLOW_EQ_in_globcond491_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_globcond517  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_globcond517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_globcond517	= { FOLLOW_NOT_in_globcond517_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond519  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond519	= { FOLLOW_EQ_in_globcond519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond567  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond567	= { FOLLOW_NUMBER_in_globcond567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond571  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond571	= { FOLLOW_ATTR_in_globcond571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_FREQ_in_globcond597  */
static	ANTLR3_BITWORD FOLLOW_KW_FREQ_in_globcond597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_FREQ_in_globcond597	= { FOLLOW_KW_FREQ_in_globcond597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond601  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond601	= { FOLLOW_NUMBER_in_globcond601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond605  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond605_bits[]	= { ANTLR3_UINT64_LIT(0x00000400A800C000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond605	= { FOLLOW_ATTR_in_globcond605_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_globcond608  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_globcond608_bits[]	= { ANTLR3_UINT64_LIT(0x000004002800C000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_globcond608	= { FOLLOW_NOT_in_globcond608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond620  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond620	= { FOLLOW_EQ_in_globcond620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEQ_in_globcond630  */
static	ANTLR3_BITWORD FOLLOW_LEQ_in_globcond630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LEQ_in_globcond630	= { FOLLOW_LEQ_in_globcond630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GEQ_in_globcond640  */
static	ANTLR3_BITWORD FOLLOW_GEQ_in_globcond640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GEQ_in_globcond640	= { FOLLOW_GEQ_in_globcond640_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSTRUCT_in_globcond650  */
static	ANTLR3_BITWORD FOLLOW_LSTRUCT_in_globcond650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LSTRUCT_in_globcond650	= { FOLLOW_LSTRUCT_in_globcond650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSTRUCT_in_globcond660  */
static	ANTLR3_BITWORD FOLLOW_RSTRUCT_in_globcond660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RSTRUCT_in_globcond660	= { FOLLOW_RSTRUCT_in_globcond660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond673  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond673_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond673	= { FOLLOW_NUMBER_in_globcond673_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_globcond721  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_globcond721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_globcond721	= { FOLLOW_bigseq_in_globcond721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_structure755  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_structure755_bits[]	= { ANTLR3_UINT64_LIT(0x000080018921D192) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_structure755	= { FOLLOW_ATTR_in_structure755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_structure782  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_structure782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_structure782	= { FOLLOW_onepos_in_structure782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEQ_in_bigseq821  */
static	ANTLR3_BITWORD FOLLOW_SEQ_in_bigseq821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SEQ_in_bigseq821	= { FOLLOW_SEQ_in_bigseq821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seqpart_in_bigseq826  */
static	ANTLR3_BITWORD FOLLOW_seqpart_in_bigseq826_bits[]	= { ANTLR3_UINT64_LIT(0x0001110000CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_seqpart_in_bigseq826	= { FOLLOW_seqpart_in_bigseq826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_muquery_in_bigseq855  */
static	ANTLR3_BITWORD FOLLOW_muquery_in_bigseq855_bits[]	= { ANTLR3_UINT64_LIT(0x0001110004CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_muquery_in_bigseq855	= { FOLLOW_muquery_in_bigseq855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repeat_in_bigseq868  */
static	ANTLR3_BITWORD FOLLOW_repeat_in_bigseq868_bits[]	= { ANTLR3_UINT64_LIT(0x0001110004CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_repeat_in_bigseq868	= { FOLLOW_repeat_in_bigseq868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_within_containing_in_bigseq879  */
static	ANTLR3_BITWORD FOLLOW_within_containing_in_bigseq879_bits[]	= { ANTLR3_UINT64_LIT(0x0001110004CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_within_containing_in_bigseq879	= { FOLLOW_within_containing_in_bigseq879_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq890  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq890_bits[]	= { ANTLR3_UINT64_LIT(0x0001110004CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq890	= { FOLLOW_bigseq_in_bigseq890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEGSTRUCT_in_bigseq900  */
static	ANTLR3_BITWORD FOLLOW_BEGSTRUCT_in_bigseq900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BEGSTRUCT_in_bigseq900	= { FOLLOW_BEGSTRUCT_in_bigseq900_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq904  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq904	= { FOLLOW_structure_in_bigseq904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENDSTRUCT_in_bigseq924  */
static	ANTLR3_BITWORD FOLLOW_ENDSTRUCT_in_bigseq924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENDSTRUCT_in_bigseq924	= { FOLLOW_ENDSTRUCT_in_bigseq924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq928  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq928	= { FOLLOW_structure_in_bigseq928_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHOLESTRUCT_in_bigseq948  */
static	ANTLR3_BITWORD FOLLOW_WHOLESTRUCT_in_bigseq948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHOLESTRUCT_in_bigseq948	= { FOLLOW_WHOLESTRUCT_in_bigseq948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq952  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq952	= { FOLLOW_structure_in_bigseq952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seqpart_in_bigseq976  */
static	ANTLR3_BITWORD FOLLOW_seqpart_in_bigseq976_bits[]	= { ANTLR3_UINT64_LIT(0x0001110000CA2148) };
static  ANTLR3_BITSET_LIST FOLLOW_seqpart_in_bigseq976	= { FOLLOW_seqpart_in_bigseq976_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_bigseq1020  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_bigseq1020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_bigseq1020	= { FOLLOW_BINOR_in_bigseq1020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq1024  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq1024_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq1024	= { FOLLOW_bigseq_in_bigseq1024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq1029  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq1029	= { FOLLOW_bigseq_in_bigseq1029_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_seqpart1060  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_seqpart1060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_seqpart1060	= { FOLLOW_LBRACKET_in_seqpart1060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_seqpart1064  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_seqpart1064_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_seqpart1064	= { FOLLOW_labeledpos_in_seqpart1064_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_seqpart1076  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_seqpart1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_seqpart1076	= { FOLLOW_LBRACKET_in_seqpart1076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_seqpart1080  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_seqpart1080_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_seqpart1080	= { FOLLOW_labeledpos_in_seqpart1080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_labeledpos1137  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_labeledpos1137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_labeledpos1137	= { FOLLOW_COLON_in_labeledpos1137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_labeledpos1141  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_labeledpos1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_labeledpos1141	= { FOLLOW_NUMBER_in_labeledpos1141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_labeledpos1144  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_labeledpos1144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_labeledpos1144	= { FOLLOW_LBRACKET_in_labeledpos1144_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_labeledpos1148  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_labeledpos1148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_labeledpos1148	= { FOLLOW_onepos_in_labeledpos1148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_labeledpos1179  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_labeledpos1179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_labeledpos1179	= { FOLLOW_onepos_in_labeledpos1179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1229  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1229	= { FOLLOW_REPOPT_in_repeat1229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_repeat1243  */
static	ANTLR3_BITWORD FOLLOW_query_in_repeat1243_bits[]	= { ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_repeat1243	= { FOLLOW_query_in_repeat1243_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1247  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1247	= { FOLLOW_REPOPT_in_repeat1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1251  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1251	= { FOLLOW_NUMBER_in_repeat1251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1255  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1255	= { FOLLOW_NUMBER_in_repeat1255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_repeat1274  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_repeat1274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_repeat1274	= { FOLLOW_LBRACKET_in_repeat1274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_repeat1278  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_repeat1278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_repeat1278	= { FOLLOW_onepos_in_repeat1278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1283  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1283	= { FOLLOW_REPOPT_in_repeat1283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1287  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1287	= { FOLLOW_NUMBER_in_repeat1287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1291  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1291	= { FOLLOW_NUMBER_in_repeat1291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINAND_in_onepos1335  */
static	ANTLR3_BITWORD FOLLOW_BINAND_in_onepos1335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINAND_in_onepos1335	= { FOLLOW_BINAND_in_onepos1335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1339  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1339_bits[]	= { ANTLR3_UINT64_LIT(0x000080018921D190) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1339	= { FOLLOW_onepos_in_onepos1339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1344  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1344	= { FOLLOW_onepos_in_onepos1344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_onepos1356  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_onepos1356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_onepos1356	= { FOLLOW_BINOR_in_onepos1356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1360  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1360_bits[]	= { ANTLR3_UINT64_LIT(0x000080018921D190) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1360	= { FOLLOW_onepos_in_onepos1360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1365  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1365	= { FOLLOW_onepos_in_onepos1365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_onepos1376  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_onepos1376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_onepos1376	= { FOLLOW_EQ_in_onepos1376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEQ_in_onepos1378  */
static	ANTLR3_BITWORD FOLLOW_LEQ_in_onepos1378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEQ_in_onepos1378	= { FOLLOW_LEQ_in_onepos1378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GEQ_in_onepos1383  */
static	ANTLR3_BITWORD FOLLOW_GEQ_in_onepos1383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GEQ_in_onepos1383	= { FOLLOW_GEQ_in_onepos1383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EEQ_in_onepos1387  */
static	ANTLR3_BITWORD FOLLOW_EEQ_in_onepos1387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EEQ_in_onepos1387	= { FOLLOW_EEQ_in_onepos1387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TEQ_in_onepos1391  */
static	ANTLR3_BITWORD FOLLOW_TEQ_in_onepos1391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_TEQ_in_onepos1391	= { FOLLOW_TEQ_in_onepos1391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_onepos1400  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_onepos1400_bits[]	= { ANTLR3_UINT64_LIT(0x0000008180000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_onepos1400	= { FOLLOW_ATTR_in_onepos1400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1404  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1404_bits[]	= { ANTLR3_UINT64_LIT(0x0000008080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1404	= { FOLLOW_NUMBER_in_onepos1404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_onepos1408  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_onepos1408_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_onepos1408	= { FOLLOW_NOT_in_onepos1408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REGEXP_in_onepos1416  */
static	ANTLR3_BITWORD FOLLOW_REGEXP_in_onepos1416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_REGEXP_in_onepos1416	= { FOLLOW_REGEXP_in_onepos1416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_onepos1430  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_onepos1430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_onepos1430	= { FOLLOW_NOT_in_onepos1430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1434  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1434	= { FOLLOW_onepos_in_onepos1434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ANYPOS_in_onepos1450  */
static	ANTLR3_BITWORD FOLLOW_ANYPOS_in_onepos1450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ANYPOS_in_onepos1450	= { FOLLOW_ANYPOS_in_onepos1450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1464  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1464	= { FOLLOW_NUMBER_in_onepos1464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NNUMBER_in_onepos1468  */
static	ANTLR3_BITWORD FOLLOW_NNUMBER_in_onepos1468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NNUMBER_in_onepos1468	= { FOLLOW_NNUMBER_in_onepos1468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_SWAP_in_onepos1479  */
static	ANTLR3_BITWORD FOLLOW_KW_SWAP_in_onepos1479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_SWAP_in_onepos1479	= { FOLLOW_KW_SWAP_in_onepos1479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1483  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1483_bits[]	= { ANTLR3_UINT64_LIT(0x000080018921D190) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1483	= { FOLLOW_NUMBER_in_onepos1483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1487  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1487	= { FOLLOW_onepos_in_onepos1487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CCOLL_in_onepos1499  */
static	ANTLR3_BITWORD FOLLOW_KW_CCOLL_in_onepos1499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CCOLL_in_onepos1499	= { FOLLOW_KW_CCOLL_in_onepos1499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1503  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1503	= { FOLLOW_NUMBER_in_onepos1503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1507  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1507_bits[]	= { ANTLR3_UINT64_LIT(0x000080018921D190) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1507	= { FOLLOW_NUMBER_in_onepos1507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1511  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1511	= { FOLLOW_onepos_in_onepos1511_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WS_in_onepos1523  */
static	ANTLR3_BITWORD FOLLOW_KW_WS_in_onepos1523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WS_in_onepos1523	= { FOLLOW_KW_WS_in_onepos1523_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1527  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1527	= { FOLLOW_NUMBER_in_onepos1527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1531  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1531	= { FOLLOW_NUMBER_in_onepos1531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WS_in_onepos1542  */
static	ANTLR3_BITWORD FOLLOW_KW_WS_in_onepos1542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WS_in_onepos1542	= { FOLLOW_KW_WS_in_onepos1542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REGEXP_in_onepos1546  */
static	ANTLR3_BITWORD FOLLOW_REGEXP_in_onepos1546_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REGEXP_in_onepos1546	= { FOLLOW_REGEXP_in_onepos1546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REGEXP_in_onepos1550  */
static	ANTLR3_BITWORD FOLLOW_REGEXP_in_onepos1550_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REGEXP_in_onepos1550	= { FOLLOW_REGEXP_in_onepos1550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REGEXP_in_onepos1554  */
static	ANTLR3_BITWORD FOLLOW_REGEXP_in_onepos1554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_REGEXP_in_onepos1554	= { FOLLOW_REGEXP_in_onepos1554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_UNION_in_muquery1582  */
static	ANTLR3_BITWORD FOLLOW_KW_UNION_in_muquery1582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_UNION_in_muquery1582	= { FOLLOW_KW_UNION_in_muquery1582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1587  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004480000) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1587	= { FOLLOW_mupart_in_muquery1587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1592  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1592	= { FOLLOW_mupart_in_muquery1592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_MEET_in_muquery1602  */
static	ANTLR3_BITWORD FOLLOW_KW_MEET_in_muquery1602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_MEET_in_muquery1602	= { FOLLOW_KW_MEET_in_muquery1602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1606  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004480000) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1606	= { FOLLOW_mupart_in_muquery1606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1611  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000008) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1611	= { FOLLOW_mupart_in_muquery1611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_muquery1620  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_muquery1620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_muquery1620	= { FOLLOW_NUMBER_in_muquery1620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_muquery1624  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_muquery1624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_muquery1624	= { FOLLOW_NUMBER_in_muquery1624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_muquery_in_mupart1670  */
static	ANTLR3_BITWORD FOLLOW_muquery_in_mupart1670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_muquery_in_mupart1670	= { FOLLOW_muquery_in_mupart1670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_mupart1679  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_mupart1679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_mupart1679	= { FOLLOW_LBRACKET_in_mupart1679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_mupart1681  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_mupart1681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_mupart1681	= { FOLLOW_labeledpos_in_mupart1681_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * cqpTreeWalker.g:35:1: prog[Corpus &c] returns [RangeStream *r = NULL] : query[c] ;
 */
static RangeStream *
prog(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    /* Initialize rule variables
     */
    r =  NULL;


    {
        // cqpTreeWalker.g:36:2: ( query[c] )
        // cqpTreeWalker.g:36:4: query[c]
        {
            FOLLOWPUSH(FOLLOW_query_in_prog70);
            query(ctx, c);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end prog */

/**
 * $ANTLR start query
 * cqpTreeWalker.g:38:1: query[Corpus &c] returns [RangeStream *r = NULL] : ( within_containing[c] | globcond[c] );
 */
static RangeStream *
query(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    RangeStream * within_containing1;
    #undef	RETURN_TYPE_within_containing1
    #define	RETURN_TYPE_within_containing1 RangeStream *

    RangeStream * globcond2;
    #undef	RETURN_TYPE_globcond2
    #define	RETURN_TYPE_globcond2 RangeStream *

    /* Initialize rule variables
     */
    r =  NULL;


    {
        {
            //  cqpTreeWalker.g:39:2: ( within_containing[c] | globcond[c] )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case KW_CONTAINING:
            case KW_WITHIN:
            	{
            		alt1=1;
            	}
                break;
            case BINAND:
            case BINOR:
            case SEQ:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto rulequeryEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // cqpTreeWalker.g:39:4: within_containing[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_within_containing_in_query86);
        	        within_containing1=within_containing(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequeryEx;
        	        }


        	        {
        	            r=
        	            within_containing1
        	            ;

        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:40:4: globcond[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_globcond_in_query94);
        	        globcond2=globcond(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequeryEx;
        	        }


        	        {
        	            r=
        	            globcond2
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end query */

/**
 * $ANTLR start within_containing
 * cqpTreeWalker.g:43:1: within_containing[Corpus &c] returns [RangeStream *r = NULL] : ( ^( KW_WITHIN ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) ) | ^( KW_CONTAINING ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) ) );
 */
static RangeStream *
within_containing(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	bool within_containing_not = false;
    	bool not_within_containing = false;

    {
        {
            //  cqpTreeWalker.g:48:2: ( ^( KW_WITHIN ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) ) | ^( KW_CONTAINING ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) ) )

            ANTLR3_UINT32 alt10;

            alt10=2;

            switch ( LA(1) )
            {
            case KW_WITHIN:
            	{
            		alt10=1;
            	}
                break;
            case KW_CONTAINING:
            	{
            		alt10=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulewithin_containingEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // cqpTreeWalker.g:48:4: ^( KW_WITHIN ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) )
        	    {
        	         MATCHT(KW_WITHIN, &FOLLOW_KW_WITHIN_in_within_containing119);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        // cqpTreeWalker.g:48:16: ( NOT )?
        	        {
        	            int alt2=2;
        	            switch ( LA(1) )
        	            {
        	                case NOT:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:48:17: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing122);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	        {
        	        	            not_within_containing=true;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_query_in_within_containing130);
        	        p=query(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        // cqpTreeWalker.g:49:13: ( NOT )?
        	        {
        	            int alt3=2;
        	            switch ( LA(1) )
        	            {
        	                case NOT:
        	                	{
        	                		alt3=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt3)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:49:14: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing146);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	        {
        	        	            within_containing_not=true;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // cqpTreeWalker.g:50:13: ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] )
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR:
        	            case BINAND:
        	            case BINOR:
        	            case KW_CONTAINING:
        	            case KW_WITHIN:
        	            case SEQ:
        	            	{
        	            		alt5=1;
        	            	}
        	                break;
        	            case COLON:
        	            	{
        	            		alt5=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 5;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;

        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:51:5: (q= structure[c] |q= query[c] )
        	        	    {
        	        	        // cqpTreeWalker.g:51:5: (q= structure[c] |q= query[c] )
        	        	        {
        	        	            int alt4=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case ATTR:
        	        	            	{
        	        	            		alt4=1;
        	        	            	}
        	        	                break;
        	        	            case BINAND:
        	        	            case BINOR:
        	        	            case KW_CONTAINING:
        	        	            case KW_WITHIN:
        	        	            case SEQ:
        	        	            	{
        	        	            		alt4=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 4;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulewithin_containingEx;

        	        	            }

        	        	            switch (alt4)
        	        	            {
        	        	        	case 1:
        	        	        	    // cqpTreeWalker.g:51:7: q= structure[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_structure_in_within_containing174);
        	        	        	        q=structure(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // cqpTreeWalker.g:51:24: q= query[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_query_in_within_containing181);
        	        	        	        q=query(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:53:5: q= alignedpart[c]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_alignedpart_in_within_containing198);
        	        	        q=alignedpart(ctx, c);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }



        	        {
        	            if (within_containing_not)
        	                        q = RQoutsideNode::create (q, c.size());
        	                     if (not_within_containing)
        	                        r = new RQnotInNode (p, q);
        	                     else
        	                        r = new RQinNode (p, q);
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:62:4: ^( KW_CONTAINING ( NOT )? p= query[c] ( NOT )? ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] ) )
        	    {
        	         MATCHT(KW_CONTAINING, &FOLLOW_KW_CONTAINING_in_within_containing228);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        // cqpTreeWalker.g:62:20: ( NOT )?
        	        {
        	            int alt6=2;
        	            switch ( LA(1) )
        	            {
        	                case NOT:
        	                	{
        	                		alt6=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt6)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:62:21: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing231);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	        {
        	        	            not_within_containing=true;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_query_in_within_containing239);
        	        p=query(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        // cqpTreeWalker.g:63:13: ( NOT )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	                case NOT:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:63:14: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing255);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	        {
        	        	            within_containing_not=true;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // cqpTreeWalker.g:64:13: ( (q= structure[c] |q= query[c] ) |q= alignedpart[c] )
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR:
        	            case BINAND:
        	            case BINOR:
        	            case KW_CONTAINING:
        	            case KW_WITHIN:
        	            case SEQ:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;
        	            case COLON:
        	            	{
        	            		alt9=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 9;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:65:5: (q= structure[c] |q= query[c] )
        	        	    {
        	        	        // cqpTreeWalker.g:65:5: (q= structure[c] |q= query[c] )
        	        	        {
        	        	            int alt8=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case ATTR:
        	        	            	{
        	        	            		alt8=1;
        	        	            	}
        	        	                break;
        	        	            case BINAND:
        	        	            case BINOR:
        	        	            case KW_CONTAINING:
        	        	            case KW_WITHIN:
        	        	            case SEQ:
        	        	            	{
        	        	            		alt8=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 8;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulewithin_containingEx;

        	        	            }

        	        	            switch (alt8)
        	        	            {
        	        	        	case 1:
        	        	        	    // cqpTreeWalker.g:65:7: q= structure[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_structure_in_within_containing283);
        	        	        	        q=structure(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // cqpTreeWalker.g:65:24: q= query[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_query_in_within_containing290);
        	        	        	        q=query(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:67:5: q= alignedpart[c]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_alignedpart_in_within_containing307);
        	        	        q=alignedpart(ctx, c);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }



        	        {
        	            if (within_containing_not)
        	                        q = RQoutsideNode::create (q, c.size());
        	                     if (not_within_containing)
        	                        r = new RQnotContainNode (p, q);
        	                     else
        	                        r = new RQcontainNode (p, q);
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulewithin_containingEx; /* Prevent compiler warnings */
    rulewithin_containingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end within_containing */

/**
 * $ANTLR start alignedpart
 * cqpTreeWalker.g:78:1: alignedpart[Corpus &c] returns [RangeStream *r = NULL] : ^( COLON al_name= ATTR q= bigseq[*al_corp] ) ;
 */
static RangeStream *
alignedpart(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    pANTLR3_BASE_TREE    al_name;
    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	Corpus *al_corp;

    al_name       = NULL;

    {
        // cqpTreeWalker.g:82:2: ( ^( COLON al_name= ATTR q= bigseq[*al_corp] ) )
        // cqpTreeWalker.g:83:4: ^( COLON al_name= ATTR q= bigseq[*al_corp] )
        {
             MATCHT(COLON, &FOLLOW_COLON_in_alignedpart361);
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }

            al_name = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_alignedpart365);
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }


            {
                al_corp = c.get_aligned((const char *) (al_name->getText(al_name))->chars); al_corp->set_default_attr (c.get_default_attr()->name); 
            }


            FOLLOWPUSH(FOLLOW_bigseq_in_alignedpart379);
            q=bigseq(ctx, *al_corp);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }


            {
                r = c.map_aligned (al_corp, q);
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulealignedpartEx; /* Prevent compiler warnings */
    rulealignedpartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end alignedpart */

/**
 * $ANTLR start globcond
 * cqpTreeWalker.g:89:1: globcond[Corpus &c] returns [RangeStream *r = NULL] : ( ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ ) | bigseq[c] );
 */
static RangeStream *
globcond(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    a1;
    pANTLR3_BASE_TREE    n2;
    pANTLR3_BASE_TREE    a2;
    pANTLR3_BASE_TREE    f;
    RangeStream * bigseq3;
    #undef	RETURN_TYPE_bigseq3
    #define	RETURN_TYPE_bigseq3 RangeStream *

    RangeStream * bigseq4;
    #undef	RETURN_TYPE_bigseq4
    #define	RETURN_TYPE_bigseq4 RangeStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	FastStream *a, *b; RQFilterPos::Op posOp; RQFilterFreq::Op freqOp; int neg = 0;

    n1       = NULL;
    a1       = NULL;
    n2       = NULL;
    a2       = NULL;
    f       = NULL;

    {
        {
            //  cqpTreeWalker.g:93:5: ( ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ ) | bigseq[c] )

            ANTLR3_UINT32 alt15;

            alt15=2;

            switch ( LA(1) )
            {
            case BINAND:
            	{
            		alt15=1;
            	}
                break;
            case BINOR:
            case SEQ:
            	{
            		alt15=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 15;
                EXCEPTION->state        = 0;


                goto ruleglobcondEx;

            }

            switch (alt15)
            {
        	case 1:
        	    // cqpTreeWalker.g:94:9: ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ )
        	    {
        	         MATCHT(BINAND, &FOLLOW_BINAND_in_globcond437);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_bigseq_in_globcond439);
        	        bigseq3=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }


        	        {
        	            r=
        	            bigseq3
        	            ;

        	        }


        	        // cqpTreeWalker.g:95:13: ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+
        	        {
        	            int cnt14=0;

        	            for (;;)
        	            {
        	                int alt14=3;
        	        	switch ( LA(1) )
        	        	{
        	        	case DOT:
        	        		{
        	        			alt14=1;
        	        		}
        	        	    break;
        	        	case KW_FREQ:
        	        		{
        	        			alt14=2;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt14)
        	        	{
        	        	    case 1:
        	        	        // cqpTreeWalker.g:95:14: ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR )
        	        	        {
        	        	             MATCHT(DOT, &FOLLOW_DOT_in_globcond459);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond463);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond467);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            // cqpTreeWalker.g:96:21: ( EQ | NOT EQ )
        	        	            {
        	        	                int alt11=2;
        	        	                switch ( LA(1) )
        	        	                {
        	        	                case EQ:
        	        	                	{
        	        	                		alt11=1;
        	        	                	}
        	        	                    break;
        	        	                case NOT:
        	        	                	{
        	        	                		alt11=2;
        	        	                	}
        	        	                    break;

        	        	                default:
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = (void *)"";
        	        	                    EXCEPTION->decisionNum  = 11;
        	        	                    EXCEPTION->state        = 0;


        	        	                    goto ruleglobcondEx;

        	        	                }

        	        	                switch (alt11)
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:96:22: EQ
        	        	            	    {
        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond491);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            posOp=RQFilterPos::F_EQ;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 2:
        	        	            	    // cqpTreeWalker.g:97:22: NOT EQ
        	        	            	    {
        	        	            	         MATCHT(NOT, &FOLLOW_NOT_in_globcond517);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond519);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            posOp=RQFilterPos::F_NEQ;
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	            n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond567);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            a2 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond571);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }



        	        	            {
        	        	                r= new RQFilterPos (r, c.get_attr ((const char *) (a1->getText(a1))->chars),
        	        	                                        c.get_attr ((const char *) (a2->getText(a2))->chars), posOp,
        	        	                                        atol ((const char *) (n1->getText(n1))->chars),
        	        	                                        atol ((const char *) (n2->getText(n2))->chars));
        	        	                                
        	        	            }


        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // cqpTreeWalker.g:105:5: ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER )
        	        	        {
        	        	             MATCHT(KW_FREQ, &FOLLOW_KW_FREQ_in_globcond597);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond601);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond605);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            // cqpTreeWalker.g:105:33: ( NOT )?
        	        	            {
        	        	                int alt12=2;
        	        	                switch ( LA(1) )
        	        	                {
        	        	                    case NOT:
        	        	                    	{
        	        	                    		alt12=1;
        	        	                    	}
        	        	                        break;
        	        	                }

        	        	                switch (alt12)
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:105:34: NOT
        	        	            	    {
        	        	            	         MATCHT(NOT, &FOLLOW_NOT_in_globcond608);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	             neg=1; 
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	            // cqpTreeWalker.g:106:6: ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT )
        	        	            {
        	        	                int alt13=5;
        	        	                switch ( LA(1) )
        	        	                {
        	        	                case EQ:
        	        	                	{
        	        	                		alt13=1;
        	        	                	}
        	        	                    break;
        	        	                case LEQ:
        	        	                	{
        	        	                		alt13=2;
        	        	                	}
        	        	                    break;
        	        	                case GEQ:
        	        	                	{
        	        	                		alt13=3;
        	        	                	}
        	        	                    break;
        	        	                case LSTRUCT:
        	        	                	{
        	        	                		alt13=4;
        	        	                	}
        	        	                    break;
        	        	                case RSTRUCT:
        	        	                	{
        	        	                		alt13=5;
        	        	                	}
        	        	                    break;

        	        	                default:
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = (void *)"";
        	        	                    EXCEPTION->decisionNum  = 13;
        	        	                    EXCEPTION->state        = 0;


        	        	                    goto ruleglobcondEx;

        	        	                }

        	        	                switch (alt13)
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:106:7: EQ
        	        	            	    {
        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond620);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_EQ;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 2:
        	        	            	    // cqpTreeWalker.g:107:7: LEQ
        	        	            	    {
        	        	            	         MATCHT(LEQ, &FOLLOW_LEQ_in_globcond630);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_LEQ;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 3:
        	        	            	    // cqpTreeWalker.g:108:7: GEQ
        	        	            	    {
        	        	            	         MATCHT(GEQ, &FOLLOW_GEQ_in_globcond640);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_GEQ;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 4:
        	        	            	    // cqpTreeWalker.g:109:7: LSTRUCT
        	        	            	    {
        	        	            	         MATCHT(LSTRUCT, &FOLLOW_LSTRUCT_in_globcond650);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_GEQ; neg=1;
        	        	            	        }


        	        	            	    }
        	        	            	    break;
        	        	            	case 5:
        	        	            	    // cqpTreeWalker.g:110:7: RSTRUCT
        	        	            	    {
        	        	            	         MATCHT(RSTRUCT, &FOLLOW_RSTRUCT_in_globcond660);
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }


        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_LEQ; neg=1;
        	        	            	        }


        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	            f = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond673);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }



        	        	            {
        	        	                r= new RQFilterFreq(r, c.get_attr ((const char *) (a1->getText(a1))->chars),
        	        	                						freqOp, neg, atoll ((const char *) (n1->getText(n1))->chars),
        	        	                						STR2NUMPOS ((const char *) (f->getText(f))->chars));
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt14 >= 1 )
        	        		{
        	        		    goto loop14;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleglobcondEx;
        	        	}
        	        	cnt14++;
        	            }
        	            loop14: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:118:9: bigseq[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_bigseq_in_globcond721);
        	        bigseq4=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }


        	        {
        	            r= 
        	            bigseq4
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleglobcondEx; /* Prevent compiler warnings */
    ruleglobcondEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end globcond */

/**
 * $ANTLR start structure
 * cqpTreeWalker.g:121:1: structure[Corpus &c] returns [RangeStream *r = NULL] : sn= ATTR (|fs= onepos[*strc] ) ;
 */
static RangeStream *
structure(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    pANTLR3_BASE_TREE    sn;
    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	Structure *strc;

    sn       = NULL;

    {
        // cqpTreeWalker.g:125:2: (sn= ATTR (|fs= onepos[*strc] ) )
        // cqpTreeWalker.g:126:4: sn= ATTR (|fs= onepos[*strc] )
        {
            sn = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_structure755);
            if  (HASEXCEPTION())
            {
                goto rulestructureEx;
            }


            {
                strc = c.get_struct ((const char *) (sn->getText(sn))->chars);
            }


            // cqpTreeWalker.g:127:6: (|fs= onepos[*strc] )
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case UP:
                	{
                		alt16=1;
                	}
                    break;
                case ANYPOS:
                case BINAND:
                case BINOR:
                case EEQ:
                case EQ:
                case GEQ:
                case KW_CCOLL:
                case KW_SWAP:
                case KW_WS:
                case LEQ:
                case NOT:
                case NUMBER:
                case TEQ:
                	{
                		alt16=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 16;
                    EXCEPTION->state        = 0;


                    goto rulestructureEx;

                }

                switch (alt16)
                {
            	case 1:
            	    // cqpTreeWalker.g:128:4: 
            	    {
            	        {
            	            r = strc->rng->whole();
            	        }


            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:129:8: fs= onepos[*strc]
            	    {
            	        FOLLOWPUSH(FOLLOW_onepos_in_structure782);
            	        fs=onepos(ctx, *strc);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructureEx;
            	        }


            	        {
            	            r = strc->rng->part(fs);
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestructureEx; /* Prevent compiler warnings */
    rulestructureEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end structure */

/**
 * $ANTLR start bigseq
 * cqpTreeWalker.g:134:1: bigseq[Corpus &c] returns [RangeStream *r = NULL] : ( ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* ) | ^( BINOR p= bigseq[c] q= bigseq[c] ) );
 */
static RangeStream *
bigseq(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    RangeStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s RangeStream *

    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	bool usesort=false;

    {
        {
            //  cqpTreeWalker.g:138:2: ( ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* ) | ^( BINOR p= bigseq[c] q= bigseq[c] ) )

            ANTLR3_UINT32 alt21;

            alt21=2;

            switch ( LA(1) )
            {
            case SEQ:
            	{
            		alt21=1;
            	}
                break;
            case BINOR:
            	{
            		alt21=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto rulebigseqEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // cqpTreeWalker.g:139:4: ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* )
        	    {
        	         MATCHT(SEQ, &FOLLOW_SEQ_in_bigseq821);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulebigseqEx;
        	            }

        	            // cqpTreeWalker.g:139:10: (s= seqpart[c] )?
        	            {
        	                int alt17=2;
        	                switch ( LA(1) )
        	                {
        	                    case LBRACKET:
        	                    	{
        	                    		alt17=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt17)
        	                {
        	            	case 1:
        	            	    // cqpTreeWalker.g:139:11: s= seqpart[c]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_seqpart_in_bigseq826);
        	            	        s=seqpart(ctx, c);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulebigseqEx;
        	            	        }


        	            	        {
        	            	            r = s;
        	            	        }


        	            	    }
        	            	    break;

        	                }
        	            }

        	            // cqpTreeWalker.g:140:4: ( (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )*

        	            for (;;)
        	            {
        	                int alt20=2;
        	                switch ( LA(1) )
        	                {
        	                case BEGSTRUCT:
        	                case BINOR:
        	                case ENDSTRUCT:
        	                case KW_CONTAINING:
        	                case KW_MEET:
        	                case KW_UNION:
        	                case KW_WITHIN:
        	                case REPOPT:
        	                case SEQ:
        	                case WHOLESTRUCT:
        	                	{
        	                		alt20=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt20)
        	                {
        	            	case 1:
        	            	    // cqpTreeWalker.g:141:5: (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )?
        	            	    {
        	            	        // cqpTreeWalker.g:141:5: (fs= muquery[c] |p= repeat[c] |p= within_containing[c] |p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) )
        	            	        {
        	            	            int alt18=7;
        	            	            switch ( LA(1) )
        	            	            {
        	            	            case KW_MEET:
        	            	            case KW_UNION:
        	            	            	{
        	            	            		alt18=1;
        	            	            	}
        	            	                break;
        	            	            case REPOPT:
        	            	            	{
        	            	            		alt18=2;
        	            	            	}
        	            	                break;
        	            	            case KW_CONTAINING:
        	            	            case KW_WITHIN:
        	            	            	{
        	            	            		alt18=3;
        	            	            	}
        	            	                break;
        	            	            case BINOR:
        	            	            case SEQ:
        	            	            	{
        	            	            		alt18=4;
        	            	            	}
        	            	                break;
        	            	            case BEGSTRUCT:
        	            	            	{
        	            	            		alt18=5;
        	            	            	}
        	            	                break;
        	            	            case ENDSTRUCT:
        	            	            	{
        	            	            		alt18=6;
        	            	            	}
        	            	                break;
        	            	            case WHOLESTRUCT:
        	            	            	{
        	            	            		alt18=7;
        	            	            	}
        	            	                break;

        	            	            default:
        	            	                CONSTRUCTEX();
        	            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            	                EXCEPTION->message      = (void *)"";
        	            	                EXCEPTION->decisionNum  = 18;
        	            	                EXCEPTION->state        = 0;


        	            	                goto rulebigseqEx;

        	            	            }

        	            	            switch (alt18)
        	            	            {
        	            	        	case 1:
        	            	        	    // cqpTreeWalker.g:142:9: fs= muquery[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_muquery_in_bigseq855);
        	            	        	        fs=muquery(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        {
        	            	        	            p = new Pos2Range (fs, 0, 1);
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 2:
        	            	        	    // cqpTreeWalker.g:143:7: p= repeat[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_repeat_in_bigseq868);
        	            	        	        p=repeat(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 3:
        	            	        	    // cqpTreeWalker.g:144:7: p= within_containing[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_within_containing_in_bigseq879);
        	            	        	        p=within_containing(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 4:
        	            	        	    // cqpTreeWalker.g:145:7: p= bigseq[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq890);
        	            	        	        p=bigseq(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 5:
        	            	        	    // cqpTreeWalker.g:146:7: ^( BEGSTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(BEGSTRUCT, &FOLLOW_BEGSTRUCT_in_bigseq900);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq904);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }



        	            	        	        {
        	            	        	            p = new Pos2Range (new BegsOfRStream (p), 0, 0);
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 6:
        	            	        	    // cqpTreeWalker.g:148:7: ^( ENDSTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(ENDSTRUCT, &FOLLOW_ENDSTRUCT_in_bigseq924);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq928);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }



        	            	        	        {
        	            	        	            p = new Pos2Range (new EndsOfRStream (p), 0, 0);
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 7:
        	            	        	    // cqpTreeWalker.g:150:7: ^( WHOLESTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(WHOLESTRUCT, &FOLLOW_WHOLESTRUCT_in_bigseq948);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq952);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }



        	            	        	    }
        	            	        	    break;

        	            	            }
        	            	        }

        	            	        {
        	            	            if (r) {
        	            	                                    r = RQConcatNodeUnsort (r, p);
        	            	                                    usesort = true;
        	            	                                } else {
        	            	                                    r = p;
        	            	                                }
        	            	        }


        	            	        // cqpTreeWalker.g:158:5: (p= seqpart[c] )?
        	            	        {
        	            	            int alt19=2;
        	            	            switch ( LA(1) )
        	            	            {
        	            	                case LBRACKET:
        	            	                	{
        	            	                		alt19=1;
        	            	                	}
        	            	                    break;
        	            	            }

        	            	            switch (alt19)
        	            	            {
        	            	        	case 1:
        	            	        	    // cqpTreeWalker.g:158:6: p= seqpart[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_seqpart_in_bigseq976);
        	            	        	        p=seqpart(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        {
        	            	        	            r = RQConcatNodeUnsort (r,p); usesort=true;
        	            	        	        }


        	            	        	    }
        	            	        	    break;

        	            	            }
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop20;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop20: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL);
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulebigseqEx;
        	            }

        	        }


        	        {
        	            if (usesort) r = new RQSortBeg (r);
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:165:4: ^( BINOR p= bigseq[c] q= bigseq[c] )
        	    {
        	         MATCHT(BINOR, &FOLLOW_BINOR_in_bigseq1020);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq1024);
        	        p=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq1029);
        	        q=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }



        	        {
        	            r = new RQUnionNode (p,q); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebigseqEx; /* Prevent compiler warnings */
    rulebigseqEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end bigseq */

/**
 * $ANTLR start seqpart
 * cqpTreeWalker.g:168:1: seqpart[Corpus &c] returns [RangeStream *r = NULL] : ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )* ;
 */
static RangeStream *
seqpart(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    FastStream * res;
    #undef	RETURN_TYPE_res
    #define	RETURN_TYPE_res FastStream *

    FastStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s FastStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	int count = 1;

    {
        // cqpTreeWalker.g:172:2: ( ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )* )
        // cqpTreeWalker.g:173:4: ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )*
        {
             MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_seqpart1060);
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }

            FOLLOWPUSH(FOLLOW_labeledpos_in_seqpart1064);
            res=labeledpos(ctx, c);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }



            // cqpTreeWalker.g:174:3: ( ^( LBRACKET s= labeledpos[c] ) )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case LBRACKET:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // cqpTreeWalker.g:175:4: ^( LBRACKET s= labeledpos[c] )
            	    {
            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_seqpart1076);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_labeledpos_in_seqpart1080);
            	        s=labeledpos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }



            	        {
            	            res = new QAndNode(res, new QMoveNode (s, -count)); count++;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


            {
                r = new Pos2Range (res, 0, count);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleseqpartEx; /* Prevent compiler warnings */
    ruleseqpartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end seqpart */

/**
 * $ANTLR start labeledpos
 * cqpTreeWalker.g:181:1: labeledpos[Corpus &c] returns [FastStream *ls = NULL] : ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) |s= onepos[c] ) ;
 */
static FastStream *
labeledpos(pcqpTreeWalker ctx, Corpus &c)
{
    FastStream * ls;


    pANTLR3_BASE_TREE    n;
    FastStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s FastStream *

    /* Initialize rule variables
     */
    ls =  NULL;



    	int label=0;

    n       = NULL;

    {
        // cqpTreeWalker.g:185:2: ( ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) |s= onepos[c] ) )
        // cqpTreeWalker.g:186:4: ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) |s= onepos[c] )
        {
            // cqpTreeWalker.g:186:4: ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) |s= onepos[c] )
            {
                int alt23=2;
                switch ( LA(1) )
                {
                case COLON:
                	{
                		alt23=1;
                	}
                    break;
                case ANYPOS:
                case BINAND:
                case BINOR:
                case EEQ:
                case EQ:
                case GEQ:
                case KW_CCOLL:
                case KW_SWAP:
                case KW_WS:
                case LEQ:
                case NOT:
                case NUMBER:
                case TEQ:
                	{
                		alt23=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 23;
                    EXCEPTION->state        = 0;


                    goto rulelabeledposEx;

                }

                switch (alt23)
                {
            	case 1:
            	    // cqpTreeWalker.g:187:9: ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) )
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_labeledpos1137);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	        n = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_labeledpos1141);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_labeledpos1144);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_onepos_in_labeledpos1148);
            	        s=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }



            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }



            	        {
            	            label = atol ((const char *) (n->getText(n))->chars);
            	        }


            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:189:9: s= onepos[c]
            	    {
            	        FOLLOWPUSH(FOLLOW_onepos_in_labeledpos1179);
            	        s=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	    }
            	    break;

                }
            }

            {
                ls = new AddLabel (s, label);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelabeledposEx; /* Prevent compiler warnings */
    rulelabeledposEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ls;
}
/* $ANTLR end labeledpos */

/**
 * $ANTLR start repeat
 * cqpTreeWalker.g:195:1: repeat[Corpus &c] returns [RangeStream *r = NULL] : ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) ) ;
 */
static RangeStream *
repeat(pcqpTreeWalker ctx, Corpus &c)
{
    RangeStream * r;


    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    n2;
    pANTLR3_BASE_TREE    n3;
    pANTLR3_BASE_TREE    n4;
    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	int rn1, rn2;

    n1       = NULL;
    n2       = NULL;
    n3       = NULL;
    n4       = NULL;

    {
        // cqpTreeWalker.g:199:2: ( ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) ) )
        // cqpTreeWalker.g:200:4: ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) )
        {
             MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1229);
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }

            // cqpTreeWalker.g:201:4: (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) )
            {
                int alt24=2;
                switch ( LA(1) )
                {
                case BINAND:
                case BINOR:
                case KW_CONTAINING:
                case KW_WITHIN:
                case SEQ:
                	{
                		alt24=1;
                	}
                    break;
                case LBRACKET:
                	{
                		alt24=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 24;
                    EXCEPTION->state        = 0;


                    goto rulerepeatEx;

                }

                switch (alt24)
                {
            	case 1:
            	    // cqpTreeWalker.g:202:5: p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER )
            	    {
            	        FOLLOWPUSH(FOLLOW_query_in_repeat1243);
            	        p=query(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	         MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1247);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1251);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1255);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }



            	        {

            	            					rn1 = atol ((const char *) (n1->getText(n1))->chars);
            	            					rn2 = atol ((const char *) (n2->getText(n2))->chars);
            	            					if (rn1 == 0 && rn2 == 1) {
            	            						r = new RQOptionalNode (p);
            	            					} else {
            	            						r = new RQRepeatNode (p, rn1, rn2);
            	            					}
            	            				
            	        }


            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:213:5: ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER )
            	    {
            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_repeat1274);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_onepos_in_repeat1278);
            	        fs=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }



            	         MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1283);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n3 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1287);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        n4 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1291);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }



            	        {

            	            					rn1 = atol ((const char *) (n3->getText(n3))->chars);
            	            					rn2 = atol ((const char *) (n4->getText(n4))->chars);
            	            					if (rn1 == 0 && rn2 == 1) {
            	            						r = new RQOptionalNode (new Pos2Range (fs));
            	            					} else {
            	            						r = new RQRepeatFSNode (fs, rn1, rn2);
            	            					}
            	            				
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulerepeatEx; /* Prevent compiler warnings */
    rulerepeatEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end repeat */

/**
 * $ANTLR start onepos
 * cqpTreeWalker.g:228:1: onepos[Corpus &c] returns [FastStream *r = NULL] : ( ^( BINAND a= onepos[c] b= onepos[c] ) | ^( BINOR a= onepos[c] b= onepos[c] ) | ^( ( EQ | LEQ | GEQ | EEQ | TEQ ) a1= ATTR (n= NUMBER )? ( NOT )? v1= REGEXP ) | ^( NOT a= onepos[c] ) | ^( ANYPOS () ) | ^(n1= NUMBER n2= NNUMBER ) | ^( KW_SWAP n= NUMBER a= onepos[c] ) | ^( KW_CCOLL f= NUMBER t= NUMBER a= onepos[c] ) | ^( KW_WS level= NUMBER seek= NUMBER ) | ^( KW_WS w1= REGEXP gr= REGEXP w2= REGEXP ) );
 */
static FastStream *
onepos(pcqpTreeWalker ctx, Corpus &c)
{
    FastStream * r;


    pANTLR3_BASE_TREE    a1;
    pANTLR3_BASE_TREE    n;
    pANTLR3_BASE_TREE    v1;
    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    n2;
    pANTLR3_BASE_TREE    f;
    pANTLR3_BASE_TREE    t;
    pANTLR3_BASE_TREE    level;
    pANTLR3_BASE_TREE    seek;
    pANTLR3_BASE_TREE    w1;
    pANTLR3_BASE_TREE    gr;
    pANTLR3_BASE_TREE    w2;
    FastStream * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a FastStream *

    FastStream * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b FastStream *

    /* Initialize rule variables
     */
    r =  NULL;



    	int neg = 0, cmp = 0, thesnum = 0;

    a1       = NULL;
    n       = NULL;
    v1       = NULL;
    n1       = NULL;
    n2       = NULL;
    f       = NULL;
    t       = NULL;
    level       = NULL;
    seek       = NULL;
    w1       = NULL;
    gr       = NULL;
    w2       = NULL;

    {
        {
            //  cqpTreeWalker.g:232:2: ( ^( BINAND a= onepos[c] b= onepos[c] ) | ^( BINOR a= onepos[c] b= onepos[c] ) | ^( ( EQ | LEQ | GEQ | EEQ | TEQ ) a1= ATTR (n= NUMBER )? ( NOT )? v1= REGEXP ) | ^( NOT a= onepos[c] ) | ^( ANYPOS () ) | ^(n1= NUMBER n2= NNUMBER ) | ^( KW_SWAP n= NUMBER a= onepos[c] ) | ^( KW_CCOLL f= NUMBER t= NUMBER a= onepos[c] ) | ^( KW_WS level= NUMBER seek= NUMBER ) | ^( KW_WS w1= REGEXP gr= REGEXP w2= REGEXP ) )

            ANTLR3_UINT32 alt28;

            alt28=10;

            switch ( LA(1) )
            {
            case BINAND:
            	{
            		alt28=1;
            	}
                break;
            case BINOR:
            	{
            		alt28=2;
            	}
                break;
            case EEQ:
            case EQ:
            case GEQ:
            case LEQ:
            case TEQ:
            	{
            		alt28=3;
            	}
                break;
            case NOT:
            	{
            		alt28=4;
            	}
                break;
            case ANYPOS:
            	{
            		alt28=5;
            	}
                break;
            case NUMBER:
            	{
            		alt28=6;
            	}
                break;
            case KW_SWAP:
            	{
            		alt28=7;
            	}
                break;
            case KW_CCOLL:
            	{
            		alt28=8;
            	}
                break;
            case KW_WS:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case NUMBER:
            					{
            						alt28=9;
            					}
            				    break;
            				case REGEXP:
            					{
            						alt28=10;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 28;
            				    EXCEPTION->state        = 10;


            				    goto ruleoneposEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 28;
            		    EXCEPTION->state        = 9;


            		    goto ruleoneposEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleoneposEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // cqpTreeWalker.g:233:4: ^( BINAND a= onepos[c] b= onepos[c] )
        	    {
        	         MATCHT(BINAND, &FOLLOW_BINAND_in_onepos1335);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1339);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1344);
        	        b=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {
        	            r = new QAndNode (a,b);
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:234:4: ^( BINOR a= onepos[c] b= onepos[c] )
        	    {
        	         MATCHT(BINOR, &FOLLOW_BINOR_in_onepos1356);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1360);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1365);
        	        b=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {
        	            r = new QOrNode (a,b);
        	        }


        	    }
        	    break;
        	case 3:
        	    // cqpTreeWalker.g:235:4: ^( ( EQ | LEQ | GEQ | EEQ | TEQ ) a1= ATTR (n= NUMBER )? ( NOT )? v1= REGEXP )
        	    {
        	        // cqpTreeWalker.g:235:6: ( EQ | LEQ | GEQ | EEQ | TEQ )
        	        {
        	            int alt25=5;
        	            switch ( LA(1) )
        	            {
        	            case EQ:
        	            	{
        	            		alt25=1;
        	            	}
        	                break;
        	            case LEQ:
        	            	{
        	            		alt25=2;
        	            	}
        	                break;
        	            case GEQ:
        	            	{
        	            		alt25=3;
        	            	}
        	                break;
        	            case EEQ:
        	            	{
        	            		alt25=4;
        	            	}
        	                break;
        	            case TEQ:
        	            	{
        	            		alt25=5;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 25;
        	                EXCEPTION->state        = 0;


        	                goto ruleoneposEx;

        	            }

        	            switch (alt25)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:235:7: EQ
        	        	    {
        	        	         MATCHT(EQ, &FOLLOW_EQ_in_onepos1376);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:235:10: LEQ
        	        	    {
        	        	         MATCHT(LEQ, &FOLLOW_LEQ_in_onepos1378);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	        {
        	        	             cmp = -1; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // cqpTreeWalker.g:235:29: GEQ
        	        	    {
        	        	         MATCHT(GEQ, &FOLLOW_GEQ_in_onepos1383);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	        {
        	        	             cmp = 1; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // cqpTreeWalker.g:235:46: EEQ
        	        	    {
        	        	         MATCHT(EEQ, &FOLLOW_EEQ_in_onepos1387);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	        {
        	        	             cmp = 2; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // cqpTreeWalker.g:235:63: TEQ
        	        	    {
        	        	         MATCHT(TEQ, &FOLLOW_TEQ_in_onepos1391);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	        {
        	        	             cmp = 3; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_onepos1400);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        // cqpTreeWalker.g:236:12: (n= NUMBER )?
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	                case NUMBER:
        	                	{
        	                		alt26=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:236:12: n= NUMBER
        	        	    {
        	        	        n = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1404);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        // cqpTreeWalker.g:236:21: ( NOT )?
        	        {
        	            int alt27=2;
        	            switch ( LA(1) )
        	            {
        	                case NOT:
        	                	{
        	                		alt27=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:236:22: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_onepos1408);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	        {
        	        	             neg = 1; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        v1 = (pANTLR3_BASE_TREE) MATCHT(REGEXP, &FOLLOW_REGEXP_in_onepos1416);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {

        	            			if (n)
        	            				thesnum = atoi ((const char *) (n->getText(n))->chars);
        	            			if (!cmp) {
        	            				r = c.get_attr ((const char *) (a1->getText(a1))->chars)->regexp2poss ((const char *) (v1->getText(v1))->chars, false);
        	            			} else if (cmp == 2) {
        	            				PosAttr *pa = c.get_attr ((const char *) (a1->getText(a1))->chars);
        	            				r = pa->id2poss (pa->str2id ((const char *) (v1->getText(v1))->chars));
        	            #ifdef MANATEE_SKETCH_ENGINE
        	            			} else if (cmp == 3) {
        	            				r = id2thesposs (&c, (const char *) (a1->getText(a1))->chars, (const char *) (v1->getText(v1))->chars, thesnum);
        	            #endif
        	            			} else {
        	            				r = c.get_attr ((const char*) (a1->getText(a1))->chars)->compare2poss ((const char *) (v1->getText(v1))->chars, cmp, false);
        	            			}
        	            			if (neg) {
        	            				if (r->final() == 0) {
        	            					// empty stream
        	            					delete r;
        	            					r = new SequenceStream (0, c.size() -1, c.size());
        	            				} else {
        	            					r = new QNotNode (r, c.size());
        	            				}
        	            			}
        	            		
        	        }


        	    }
        	    break;
        	case 4:
        	    // cqpTreeWalker.g:262:7: ^( NOT a= onepos[c] )
        	    {
        	         MATCHT(NOT, &FOLLOW_NOT_in_onepos1430);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1434);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {
        	            r = new QNotNode (a, c.size());
        	        }


        	    }
        	    break;
        	case 5:
        	    // cqpTreeWalker.g:263:4: ^( ANYPOS () )
        	    {
        	         MATCHT(ANYPOS, &FOLLOW_ANYPOS_in_onepos1450);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	            // cqpTreeWalker.g:263:13: ()
        	            // cqpTreeWalker.g:263:14: 
        	            {
        	            }


        	            MATCHT(ANTLR3_TOKEN_UP, NULL);
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	        }


        	        {
        	            r = new SequenceStream (0, c.size() -1, c.size());
        	        }


        	    }
        	    break;
        	case 6:
        	    // cqpTreeWalker.g:264:4: ^(n1= NUMBER n2= NNUMBER )
        	    {
        	        n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1464);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        n2 = (pANTLR3_BASE_TREE) MATCHT(NNUMBER, &FOLLOW_NNUMBER_in_onepos1468);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        {

        	            		Position beg = atoll((const char *) (n1->getText(n1))->chars);
        	            		Position end = llabs(atoll((const char *) (n2->getText(n2))->chars));
        	            		r = new SequenceStream (beg, end, c.size());
        	            		
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	    }
        	    break;
        	case 7:
        	    // cqpTreeWalker.g:270:4: ^( KW_SWAP n= NUMBER a= onepos[c] )
        	    {
        	         MATCHT(KW_SWAP, &FOLLOW_KW_SWAP_in_onepos1479);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        n = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1483);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1487);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {

        	            		Position coll = atol((const char *) (n->getText(n))->chars);
        	            		r = new SwapKwicColl (a, coll);
        	            		
        	        }


        	    }
        	    break;
        	case 8:
        	    // cqpTreeWalker.g:275:4: ^( KW_CCOLL f= NUMBER t= NUMBER a= onepos[c] )
        	    {
        	         MATCHT(KW_CCOLL, &FOLLOW_KW_CCOLL_in_onepos1499);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        f = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1503);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        t = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1507);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1511);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {

        	            		int from = atol((const char *) (f->getText(f))->chars);
        	            		int to = atol((const char *) (t->getText(t))->chars);
        	            		r = new ChangeLabel (a, from, to);
        	            		
        	        }


        	    }
        	    break;
        	case 9:
        	    // cqpTreeWalker.g:281:4: ^( KW_WS level= NUMBER seek= NUMBER )
        	    {
        	         MATCHT(KW_WS, &FOLLOW_KW_WS_in_onepos1523);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        level = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1527);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        seek = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1531);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {

        	            #ifdef MANATEE_SKETCH_ENGINE
        	            		int l = atoi((const char *) (level->getText(level))->chars);
        	            		Position s = atoll((const char *) (seek->getText(seek))->chars);
        	            		WMap *ws = new_WMap (c.get_conf("WSBASE"), c.get_confpath(), l, s);
        	            		std::vector<FastStream*> *svec = new std::vector<FastStream*>();
        	            		svec->push_back (ws->poss());
        	            		r = new QOrVNode_clean_wmap (svec, ws);
        	            #else
        	                    throw EvalQueryException (": word sketches not supported");
        	            #endif
        	            		
        	        }


        	    }
        	    break;
        	case 10:
        	    // cqpTreeWalker.g:294:4: ^( KW_WS w1= REGEXP gr= REGEXP w2= REGEXP )
        	    {
        	         MATCHT(KW_WS, &FOLLOW_KW_WS_in_onepos1542);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        w1 = (pANTLR3_BASE_TREE) MATCHT(REGEXP, &FOLLOW_REGEXP_in_onepos1546);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        gr = (pANTLR3_BASE_TREE) MATCHT(REGEXP, &FOLLOW_REGEXP_in_onepos1550);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        w2 = (pANTLR3_BASE_TREE) MATCHT(REGEXP, &FOLLOW_REGEXP_in_onepos1554);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }



        	        {

        	            #ifdef MANATEE_SKETCH_ENGINE
        	            		std::vector<FastStream*> *svec = new std::vector<FastStream*>();
        	            		PosAttr *pa = c.get_attr (c.get_conf("WSATTR"));
        	            		const char *locale = c.get_conf(c.get_conf("WSATTR") + ".LOCALE").c_str();
        	            		WMap *ws0 = new_WMap (c.get_conf("WSBASE"), c.get_confpath());
        	            		const char *pat1 = (const char *) (w1->getText(w1))->chars;
        	            		const char *pat2 = (const char *) (w2->getText(w2))->chars;
        	            		regexp_pattern re1 (pat1, locale, c.get_conf("ENCODING").c_str());
        	            		re1.compile();
        	            		regexp_pattern re2 (pat2, locale, c.get_conf("ENCODING").c_str());
        	            		re2.compile();
        	            		do {
        	            			if (re1.no_meta_chars()) {
        	            				if (!ws0->findid (pa->str2id (pat1)))
        	            					break;
        	            			} else if (!re1.match (pa->id2str (ws0->getid())))
        	            				continue;
        	            			WMap *ws1 = ws0->nextlevel();
        	            			Generator<int> *gen = ws1->regexp2ids ((const char *) (gr->getText(gr))->chars);
        	            			while (!gen->end()) {
        	            				int id = gen->next();
        	            				if (!ws1->findid(id))
        	            					continue;
        	            				WMap *ws2 = ws1->nextlevel();
        	            				do {
        	            					if (re2.no_meta_chars()) {
        	            						if (!ws2->findid (pa->str2id (pat2)))
        	            							break;
        	            					} else if (!re2.match (pa->id2str (ws2->getid())))
        	            						continue;
        	            					svec->push_back (ws2->poss());
        	            				} while (ws2->next());
        	            				delete ws2;
        	            			}
        	            			delete gen;
        	            			delete ws1;
        	            		} while (ws0->next());
        	            		if (svec->empty()) {
        	            			delete ws0;
        	            			delete svec;
        	            			r = new EmptyStream();
        	            		} else
        	            			r = new QOrVNode_clean_wmap (svec, ws0);
        	            #else
        	                    throw EvalQueryException (": word sketches not supported");
        	            #endif
        	            		
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleoneposEx; /* Prevent compiler warnings */
    ruleoneposEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end onepos */

/**
 * $ANTLR start muquery
 * cqpTreeWalker.g:346:1: muquery[Corpus &c] returns [FastStream *r = NULL] : ( ^( KW_UNION a= mupart[c] b= mupart[c] ) | ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER |) ) );
 */
static FastStream *
muquery(pcqpTreeWalker ctx, Corpus &c)
{
    FastStream * r;


    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    n2;
    FastStream * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a FastStream *

    FastStream * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b FastStream *

    /* Initialize rule variables
     */
    r =  NULL;


    n1       = NULL;
    n2       = NULL;

    {
        {
            //  cqpTreeWalker.g:347:2: ( ^( KW_UNION a= mupart[c] b= mupart[c] ) | ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER |) ) )

            ANTLR3_UINT32 alt30;

            alt30=2;

            switch ( LA(1) )
            {
            case KW_UNION:
            	{
            		alt30=1;
            	}
                break;
            case KW_MEET:
            	{
            		alt30=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;


                goto rulemuqueryEx;

            }

            switch (alt30)
            {
        	case 1:
        	    // cqpTreeWalker.g:348:4: ^( KW_UNION a= mupart[c] b= mupart[c] )
        	    {
        	         MATCHT(KW_UNION, &FOLLOW_KW_UNION_in_muquery1582);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1587);
        	        a=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1592);
        	        b=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }



        	        {
        	            r = new QOrNode (a,b);
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:349:4: ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER |) )
        	    {
        	         MATCHT(KW_MEET, &FOLLOW_KW_MEET_in_muquery1602);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1606);
        	        a=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1611);
        	        b=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        // cqpTreeWalker.g:350:4: (n1= NUMBER n2= NUMBER |)
        	        {
        	            int alt29=2;
        	            switch ( LA(1) )
        	            {
        	            case NUMBER:
        	            	{
        	            		alt29=1;
        	            	}
        	                break;
        	            case UP:
        	            	{
        	            		alt29=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 29;
        	                EXCEPTION->state        = 0;


        	                goto rulemuqueryEx;

        	            }

        	            switch (alt29)
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:350:5: n1= NUMBER n2= NUMBER
        	        	    {
        	        	        n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_muquery1620);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemuqueryEx;
        	        	        }


        	        	        n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_muquery1624);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemuqueryEx;
        	        	        }


        	        	        {

        	        	            					int i1 = atol ((const char *) (n1->getText(n1))->chars);
        	        	            					int i2 = atol ((const char *) (n2->getText(n2))->chars);
        	        	            					if (i1 == i2)
        	        	            						r = new QAndNode(a, new QMoveNode (b, -i1));
        	        	            					else
        	        	            						r = new BegsOfRStream (new RQinNode (new Pos2Range (a),
        	        	            									new Pos2Range (b, -i2, -i1+1)));
        	        	            				
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:361:5: 
        	        	    {
        	        	        {
        	        	            r = new QAndNode(a, new QMoveNode (b, -1));
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemuqueryEx; /* Prevent compiler warnings */
    rulemuqueryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end muquery */

/**
 * $ANTLR start mupart
 * cqpTreeWalker.g:366:1: mupart[Corpus &c] returns [FastStream *r = NULL] : ( muquery[c] | ^( LBRACKET labeledpos[c] ) );
 */
static FastStream *
mupart(pcqpTreeWalker ctx, Corpus &c)
{
    FastStream * r;


    FastStream * muquery5;
    #undef	RETURN_TYPE_muquery5
    #define	RETURN_TYPE_muquery5 FastStream *

    FastStream * labeledpos6;
    #undef	RETURN_TYPE_labeledpos6
    #define	RETURN_TYPE_labeledpos6 FastStream *

    /* Initialize rule variables
     */
    r =  NULL;


    {
        {
            //  cqpTreeWalker.g:367:2: ( muquery[c] | ^( LBRACKET labeledpos[c] ) )

            ANTLR3_UINT32 alt31;

            alt31=2;

            switch ( LA(1) )
            {
            case KW_MEET:
            case KW_UNION:
            	{
            		alt31=1;
            	}
                break;
            case LBRACKET:
            	{
            		alt31=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 31;
                EXCEPTION->state        = 0;


                goto rulemupartEx;

            }

            switch (alt31)
            {
        	case 1:
        	    // cqpTreeWalker.g:368:4: muquery[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_muquery_in_mupart1670);
        	        muquery5=muquery(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }


        	        {
        	             r=
        	            muquery5
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:369:4: ^( LBRACKET labeledpos[c] )
        	    {
        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_mupart1679);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_labeledpos_in_mupart1681);
        	        labeledpos6=labeledpos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }



        	        {
        	            r=
        	            labeledpos6
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemupartEx; /* Prevent compiler warnings */
    rulemupartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return r;
}
/* $ANTLR end mupart */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
