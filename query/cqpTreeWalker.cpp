/** \file
 *  This C source file was generated by $ANTLR version 3.2 Fedora release 15 (Rawhide) Tue Feb  8 02:02:23 UTC 2011
 *
 *     -  From the grammar source file : cqpTreeWalker.g
 *     -                            On : 2013-05-10 15:01:50
 *     -           for the tree parser : cqpTreeWalkerTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

    // Copyright (c) 1999-2010 Pavel Rychly

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "cqpTreeWalker.hpp"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pcqpTreeWalker_##scope##_SCOPE
#define SCOPE_STACK(scope)  pcqpTreeWalker_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pcqpTreeWalker_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pcqpTreeWalker_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO		
#undef		SEEK    
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   cqpTreeWalkerTokenNames[42+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "OPT",
        (pANTLR3_UINT8) "REPOPT",
        (pANTLR3_UINT8) "SEQ",
        (pANTLR3_UINT8) "ANYPOS",
        (pANTLR3_UINT8) "BEGSTRUCT",
        (pANTLR3_UINT8) "ENDSTRUCT",
        (pANTLR3_UINT8) "WHOLESTRUCT",
        (pANTLR3_UINT8) "KW_MEET",
        (pANTLR3_UINT8) "KW_UNION",
        (pANTLR3_UINT8) "KW_WITHIN",
        (pANTLR3_UINT8) "KW_CONTAINING",
        (pANTLR3_UINT8) "KW_MU",
        (pANTLR3_UINT8) "KW_FREQ",
        (pANTLR3_UINT8) "WS_",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "NNUMBER",
        (pANTLR3_UINT8) "ATTR",
        (pANTLR3_UINT8) "REGEXP",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "LBRACKET",
        (pANTLR3_UINT8) "RBRACKET",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "QUEST",
        (pANTLR3_UINT8) "BINOR",
        (pANTLR3_UINT8) "BINAND",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "SEMI",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "EQ",
        (pANTLR3_UINT8) "EEQ",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "LEQ",
        (pANTLR3_UINT8) "GEQ",
        (pANTLR3_UINT8) "LSTRUCT",
        (pANTLR3_UINT8) "RSTRUCT",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "POSNUM"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static RangeStream *	prog    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	query    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	within_containing    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	alignedpart    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	globcond    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	structure    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	bigseq    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	seqpart    (pcqpTreeWalker ctx, Corpus &c);
static FastStream *	labeledpos    (pcqpTreeWalker ctx, Corpus &c);
static RangeStream *	repeat    (pcqpTreeWalker ctx, Corpus &c);
static FastStream *	onepos    (pcqpTreeWalker ctx, Corpus &c);
static FastStream *	muquery    (pcqpTreeWalker ctx, Corpus &c);
static FastStream *	mupart    (pcqpTreeWalker ctx, Corpus &c);
static void	cqpTreeWalkerFree(pcqpTreeWalker ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "cqpTreeWalker.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new cqpTreeWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcqpTreeWalker
cqpTreeWalkerNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return cqpTreeWalkerNewSSD(instream, NULL);
}

/** \brief Create a new cqpTreeWalker parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pcqpTreeWalker
cqpTreeWalkerNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pcqpTreeWalker ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pcqpTreeWalker) ANTLR3_CALLOC(1, sizeof(cqpTreeWalker));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in cqpTreeWalker.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);
    /* Install the implementation of our cqpTreeWalker interface
     */
    ctx->prog	= prog;
    ctx->query	= query;
    ctx->within_containing	= within_containing;
    ctx->alignedpart	= alignedpart;
    ctx->globcond	= globcond;
    ctx->structure	= structure;
    ctx->bigseq	= bigseq;
    ctx->seqpart	= seqpart;
    ctx->labeledpos	= labeledpos;
    ctx->repeat	= repeat;
    ctx->onepos	= onepos;
    ctx->muquery	= muquery;
    ctx->mupart	= mupart;
    ctx->free			= cqpTreeWalkerFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    


        RECOGNIZER->displayRecognitionError = throwEvalQueryException;

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = cqpTreeWalkerTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 cqpTreeWalkerFree(pcqpTreeWalker ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this tree parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return cqpTreeWalkerTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_prog70  */
static	ANTLR3_BITWORD FOLLOW_query_in_prog70_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_prog70	= { FOLLOW_query_in_prog70_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_within_containing_in_query86  */
static	ANTLR3_BITWORD FOLLOW_within_containing_in_query86_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_within_containing_in_query86	= { FOLLOW_within_containing_in_query86_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_globcond_in_query94  */
static	ANTLR3_BITWORD FOLLOW_globcond_in_query94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_globcond_in_query94	= { FOLLOW_globcond_in_query94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_WITHIN_in_within_containing119  */
static	ANTLR3_BITWORD FOLLOW_KW_WITHIN_in_within_containing119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_WITHIN_in_within_containing119	= { FOLLOW_KW_WITHIN_in_within_containing119_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing123  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing123_bits[]	= { ANTLR3_UINT64_LIT(0x0000009180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing123	= { FOLLOW_query_in_within_containing123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing145  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing145_bits[]	= { ANTLR3_UINT64_LIT(0x0000009180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing145	= { FOLLOW_NOT_in_within_containing145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_within_containing183  */
static	ANTLR3_BITWORD FOLLOW_structure_in_within_containing183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_within_containing183	= { FOLLOW_structure_in_within_containing183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing190  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing190	= { FOLLOW_query_in_within_containing190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alignedpart_in_within_containing207  */
static	ANTLR3_BITWORD FOLLOW_alignedpart_in_within_containing207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_alignedpart_in_within_containing207	= { FOLLOW_alignedpart_in_within_containing207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_CONTAINING_in_within_containing237  */
static	ANTLR3_BITWORD FOLLOW_KW_CONTAINING_in_within_containing237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_CONTAINING_in_within_containing237	= { FOLLOW_KW_CONTAINING_in_within_containing237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing241  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing241_bits[]	= { ANTLR3_UINT64_LIT(0x0000009180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing241	= { FOLLOW_query_in_within_containing241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_within_containing264  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_within_containing264_bits[]	= { ANTLR3_UINT64_LIT(0x0000009180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_within_containing264	= { FOLLOW_NOT_in_within_containing264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_within_containing302  */
static	ANTLR3_BITWORD FOLLOW_structure_in_within_containing302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_within_containing302	= { FOLLOW_structure_in_within_containing302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_within_containing309  */
static	ANTLR3_BITWORD FOLLOW_query_in_within_containing309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_within_containing309	= { FOLLOW_query_in_within_containing309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alignedpart_in_within_containing326  */
static	ANTLR3_BITWORD FOLLOW_alignedpart_in_within_containing326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_alignedpart_in_within_containing326	= { FOLLOW_alignedpart_in_within_containing326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_alignedpart380  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_alignedpart380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_alignedpart380	= { FOLLOW_COLON_in_alignedpart380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_alignedpart384  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_alignedpart384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_alignedpart384	= { FOLLOW_ATTR_in_alignedpart384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_alignedpart398  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_alignedpart398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_alignedpart398	= { FOLLOW_bigseq_in_alignedpart398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINAND_in_globcond456  */
static	ANTLR3_BITWORD FOLLOW_BINAND_in_globcond456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINAND_in_globcond456	= { FOLLOW_BINAND_in_globcond456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_globcond458  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_globcond458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200010000) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_globcond458	= { FOLLOW_bigseq_in_globcond458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_globcond478  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_globcond478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_globcond478	= { FOLLOW_DOT_in_globcond478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond482  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond482	= { FOLLOW_NUMBER_in_globcond482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond486  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond486_bits[]	= { ANTLR3_UINT64_LIT(0x000000A000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond486	= { FOLLOW_ATTR_in_globcond486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond510  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond510	= { FOLLOW_EQ_in_globcond510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_globcond536  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_globcond536_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_globcond536	= { FOLLOW_NOT_in_globcond536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond538  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond538	= { FOLLOW_EQ_in_globcond538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond586  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond586	= { FOLLOW_NUMBER_in_globcond586_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond590  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond590	= { FOLLOW_ATTR_in_globcond590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_FREQ_in_globcond616  */
static	ANTLR3_BITWORD FOLLOW_KW_FREQ_in_globcond616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_FREQ_in_globcond616	= { FOLLOW_KW_FREQ_in_globcond616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond620  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond620	= { FOLLOW_NUMBER_in_globcond620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_globcond624  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_globcond624_bits[]	= { ANTLR3_UINT64_LIT(0x00000FA000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_globcond624	= { FOLLOW_ATTR_in_globcond624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_globcond627  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_globcond627_bits[]	= { ANTLR3_UINT64_LIT(0x00000F2000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_globcond627	= { FOLLOW_NOT_in_globcond627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_globcond639  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_globcond639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_globcond639	= { FOLLOW_EQ_in_globcond639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEQ_in_globcond649  */
static	ANTLR3_BITWORD FOLLOW_LEQ_in_globcond649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LEQ_in_globcond649	= { FOLLOW_LEQ_in_globcond649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GEQ_in_globcond659  */
static	ANTLR3_BITWORD FOLLOW_GEQ_in_globcond659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_GEQ_in_globcond659	= { FOLLOW_GEQ_in_globcond659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LSTRUCT_in_globcond669  */
static	ANTLR3_BITWORD FOLLOW_LSTRUCT_in_globcond669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_LSTRUCT_in_globcond669	= { FOLLOW_LSTRUCT_in_globcond669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSTRUCT_in_globcond679  */
static	ANTLR3_BITWORD FOLLOW_RSTRUCT_in_globcond679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_RSTRUCT_in_globcond679	= { FOLLOW_RSTRUCT_in_globcond679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_globcond692  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_globcond692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_globcond692	= { FOLLOW_NUMBER_in_globcond692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_globcond740  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_globcond740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_globcond740	= { FOLLOW_bigseq_in_globcond740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_structure774  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_structure774_bits[]	= { ANTLR3_UINT64_LIT(0x000003E180040082) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_structure774	= { FOLLOW_ATTR_in_structure774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_structure801  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_structure801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_structure801	= { FOLLOW_onepos_in_structure801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SEQ_in_bigseq840  */
static	ANTLR3_BITWORD FOLLOW_SEQ_in_bigseq840_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SEQ_in_bigseq840	= { FOLLOW_SEQ_in_bigseq840_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seqpart_in_bigseq845  */
static	ANTLR3_BITWORD FOLLOW_seqpart_in_bigseq845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_seqpart_in_bigseq845	= { FOLLOW_seqpart_in_bigseq845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_muquery_in_bigseq874  */
static	ANTLR3_BITWORD FOLLOW_muquery_in_bigseq874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000181107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_muquery_in_bigseq874	= { FOLLOW_muquery_in_bigseq874_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repeat_in_bigseq887  */
static	ANTLR3_BITWORD FOLLOW_repeat_in_bigseq887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000181107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_repeat_in_bigseq887	= { FOLLOW_repeat_in_bigseq887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_within_containing_in_bigseq898  */
static	ANTLR3_BITWORD FOLLOW_within_containing_in_bigseq898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000181107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_within_containing_in_bigseq898	= { FOLLOW_within_containing_in_bigseq898_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq909  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000181107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq909	= { FOLLOW_bigseq_in_bigseq909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEGSTRUCT_in_bigseq919  */
static	ANTLR3_BITWORD FOLLOW_BEGSTRUCT_in_bigseq919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BEGSTRUCT_in_bigseq919	= { FOLLOW_BEGSTRUCT_in_bigseq919_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq923  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq923	= { FOLLOW_structure_in_bigseq923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENDSTRUCT_in_bigseq943  */
static	ANTLR3_BITWORD FOLLOW_ENDSTRUCT_in_bigseq943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENDSTRUCT_in_bigseq943	= { FOLLOW_ENDSTRUCT_in_bigseq943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq947  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq947	= { FOLLOW_structure_in_bigseq947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHOLESTRUCT_in_bigseq967  */
static	ANTLR3_BITWORD FOLLOW_WHOLESTRUCT_in_bigseq967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHOLESTRUCT_in_bigseq967	= { FOLLOW_WHOLESTRUCT_in_bigseq967_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_structure_in_bigseq971  */
static	ANTLR3_BITWORD FOLLOW_structure_in_bigseq971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_structure_in_bigseq971	= { FOLLOW_structure_in_bigseq971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_seqpart_in_bigseq995  */
static	ANTLR3_BITWORD FOLLOW_seqpart_in_bigseq995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180107F68) };
static  ANTLR3_BITSET_LIST FOLLOW_seqpart_in_bigseq995	= { FOLLOW_seqpart_in_bigseq995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_bigseq1039  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_bigseq1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_bigseq1039	= { FOLLOW_BINOR_in_bigseq1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq1043  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq1043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000180106040) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq1043	= { FOLLOW_bigseq_in_bigseq1043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bigseq_in_bigseq1048  */
static	ANTLR3_BITWORD FOLLOW_bigseq_in_bigseq1048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_bigseq_in_bigseq1048	= { FOLLOW_bigseq_in_bigseq1048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_seqpart1079  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_seqpart1079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_seqpart1079	= { FOLLOW_LBRACKET_in_seqpart1079_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_seqpart1083  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_seqpart1083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_seqpart1083	= { FOLLOW_labeledpos_in_seqpart1083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_seqpart1095  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_seqpart1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_seqpart1095	= { FOLLOW_LBRACKET_in_seqpart1095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_seqpart1099  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_seqpart1099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_seqpart1099	= { FOLLOW_labeledpos_in_seqpart1099_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_labeledpos1156  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_labeledpos1156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_labeledpos1156	= { FOLLOW_COLON_in_labeledpos1156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_labeledpos1160  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_labeledpos1160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_labeledpos1160	= { FOLLOW_NUMBER_in_labeledpos1160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_labeledpos1163  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_labeledpos1163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_labeledpos1163	= { FOLLOW_LBRACKET_in_labeledpos1163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_labeledpos1167  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_labeledpos1167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_labeledpos1167	= { FOLLOW_onepos_in_labeledpos1167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_labeledpos1198  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_labeledpos1198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_labeledpos1198	= { FOLLOW_onepos_in_labeledpos1198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1248  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1248	= { FOLLOW_REPOPT_in_repeat1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_query_in_repeat1262  */
static	ANTLR3_BITWORD FOLLOW_query_in_repeat1262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_query_in_repeat1262	= { FOLLOW_query_in_repeat1262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1266  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1266	= { FOLLOW_REPOPT_in_repeat1266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1270  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1270	= { FOLLOW_NUMBER_in_repeat1270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1274  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1274	= { FOLLOW_NUMBER_in_repeat1274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_repeat1293  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_repeat1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_repeat1293	= { FOLLOW_LBRACKET_in_repeat1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_repeat1297  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_repeat1297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_repeat1297	= { FOLLOW_onepos_in_repeat1297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPOPT_in_repeat1302  */
static	ANTLR3_BITWORD FOLLOW_REPOPT_in_repeat1302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_REPOPT_in_repeat1302	= { FOLLOW_REPOPT_in_repeat1302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1306  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1306	= { FOLLOW_NUMBER_in_repeat1306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_repeat1310  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_repeat1310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_repeat1310	= { FOLLOW_NUMBER_in_repeat1310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINAND_in_onepos1354  */
static	ANTLR3_BITWORD FOLLOW_BINAND_in_onepos1354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINAND_in_onepos1354	= { FOLLOW_BINAND_in_onepos1354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1358  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1358_bits[]	= { ANTLR3_UINT64_LIT(0x000003E180040088) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1358	= { FOLLOW_onepos_in_onepos1358_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1363  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1363	= { FOLLOW_onepos_in_onepos1363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_onepos1375  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_onepos1375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_onepos1375	= { FOLLOW_BINOR_in_onepos1375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1379  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1379_bits[]	= { ANTLR3_UINT64_LIT(0x000003E180040088) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1379	= { FOLLOW_onepos_in_onepos1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1384  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1384	= { FOLLOW_onepos_in_onepos1384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQ_in_onepos1395  */
static	ANTLR3_BITWORD FOLLOW_EQ_in_onepos1395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EQ_in_onepos1395	= { FOLLOW_EQ_in_onepos1395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEQ_in_onepos1397  */
static	ANTLR3_BITWORD FOLLOW_LEQ_in_onepos1397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEQ_in_onepos1397	= { FOLLOW_LEQ_in_onepos1397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GEQ_in_onepos1402  */
static	ANTLR3_BITWORD FOLLOW_GEQ_in_onepos1402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GEQ_in_onepos1402	= { FOLLOW_GEQ_in_onepos1402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EEQ_in_onepos1406  */
static	ANTLR3_BITWORD FOLLOW_EEQ_in_onepos1406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_EEQ_in_onepos1406	= { FOLLOW_EEQ_in_onepos1406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_in_onepos1413  */
static	ANTLR3_BITWORD FOLLOW_ATTR_in_onepos1413_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_in_onepos1413	= { FOLLOW_ATTR_in_onepos1413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_onepos1416  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_onepos1416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_onepos1416	= { FOLLOW_NOT_in_onepos1416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REGEXP_in_onepos1424  */
static	ANTLR3_BITWORD FOLLOW_REGEXP_in_onepos1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_REGEXP_in_onepos1424	= { FOLLOW_REGEXP_in_onepos1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_onepos1438  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_onepos1438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_onepos1438	= { FOLLOW_NOT_in_onepos1438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onepos_in_onepos1442  */
static	ANTLR3_BITWORD FOLLOW_onepos_in_onepos1442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_onepos_in_onepos1442	= { FOLLOW_onepos_in_onepos1442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ANYPOS_in_onepos1458  */
static	ANTLR3_BITWORD FOLLOW_ANYPOS_in_onepos1458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ANYPOS_in_onepos1458	= { FOLLOW_ANYPOS_in_onepos1458_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_onepos1472  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_onepos1472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_onepos1472	= { FOLLOW_NUMBER_in_onepos1472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_UNION_in_muquery1503  */
static	ANTLR3_BITWORD FOLLOW_KW_UNION_in_muquery1503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_UNION_in_muquery1503	= { FOLLOW_KW_UNION_in_muquery1503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1508  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001001800) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1508	= { FOLLOW_mupart_in_muquery1508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1513  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1513	= { FOLLOW_mupart_in_muquery1513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KW_MEET_in_muquery1523  */
static	ANTLR3_BITWORD FOLLOW_KW_MEET_in_muquery1523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_KW_MEET_in_muquery1523	= { FOLLOW_KW_MEET_in_muquery1523_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1527  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001001800) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1527	= { FOLLOW_mupart_in_muquery1527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mupart_in_muquery1532  */
static	ANTLR3_BITWORD FOLLOW_mupart_in_muquery1532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040008) };
static  ANTLR3_BITSET_LIST FOLLOW_mupart_in_muquery1532	= { FOLLOW_mupart_in_muquery1532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_muquery1541  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_muquery1541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_muquery1541	= { FOLLOW_NUMBER_in_muquery1541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_muquery1545  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_muquery1545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_muquery1545	= { FOLLOW_NUMBER_in_muquery1545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_muquery_in_mupart1591  */
static	ANTLR3_BITWORD FOLLOW_muquery_in_mupart1591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_muquery_in_mupart1591	= { FOLLOW_muquery_in_mupart1591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LBRACKET_in_mupart1600  */
static	ANTLR3_BITWORD FOLLOW_LBRACKET_in_mupart1600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LBRACKET_in_mupart1600	= { FOLLOW_LBRACKET_in_mupart1600_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_labeledpos_in_mupart1602  */
static	ANTLR3_BITWORD FOLLOW_labeledpos_in_mupart1602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_labeledpos_in_mupart1602	= { FOLLOW_labeledpos_in_mupart1602_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start prog
 * cqpTreeWalker.g:31:1: prog[Corpus &c] returns [RangeStream *r] : query[c] ;
 */
static RangeStream *
prog(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    /* Initialize rule variables
     */


    {
        // cqpTreeWalker.g:32:2: ( query[c] )
        // cqpTreeWalker.g:32:4: query[c]
        {
            FOLLOWPUSH(FOLLOW_query_in_prog70);
            query(ctx, c);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end prog */

/** 
 * $ANTLR start query
 * cqpTreeWalker.g:34:1: query[Corpus &c] returns [RangeStream *r] : ( within_containing[c] | globcond[c] );
 */
static RangeStream *
query(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    RangeStream * within_containing1;
    #undef	RETURN_TYPE_within_containing1
    #define	RETURN_TYPE_within_containing1 RangeStream *

    RangeStream * globcond2;
    #undef	RETURN_TYPE_globcond2
    #define	RETURN_TYPE_globcond2 RangeStream *

    /* Initialize rule variables
     */


    within_containing1 = NULL;
    globcond2 = NULL;

    {
        {
            //  cqpTreeWalker.g:35:2: ( within_containing[c] | globcond[c] )
            
            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) ) 
            {
            case KW_WITHIN:
            case KW_CONTAINING:
            	{
            		alt1=1;
            	}
                break;
            case SEQ:
            case BINOR:
            case BINAND:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto rulequeryEx;
            }

            switch (alt1) 
            {
        	case 1:
        	    // cqpTreeWalker.g:35:4: within_containing[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_within_containing_in_query86);
        	        within_containing1=within_containing(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequeryEx;
        	        }

        	        {
        	            r=within_containing1;
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:36:4: globcond[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_globcond_in_query94);
        	        globcond2=globcond(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulequeryEx;
        	        }

        	        {
        	            r=globcond2;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulequeryEx; /* Prevent compiler warnings */
    rulequeryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end query */

/** 
 * $ANTLR start within_containing
 * cqpTreeWalker.g:39:1: within_containing[Corpus &c] returns [RangeStream *r] : ( ^( KW_WITHIN p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) ) | ^( KW_CONTAINING p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) ) );
 */
static RangeStream *
within_containing(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */



    	bool within_containing_not = false;

    p = NULL;
    q = NULL;

    {
        {
            //  cqpTreeWalker.g:43:2: ( ^( KW_WITHIN p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) ) | ^( KW_CONTAINING p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) ) )
            
            ANTLR3_UINT32 alt8;

            alt8=2;

            switch ( LA(1) ) 
            {
            case KW_WITHIN:
            	{
            		alt8=1;
            	}
                break;
            case KW_CONTAINING:
            	{
            		alt8=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulewithin_containingEx;
            }

            switch (alt8) 
            {
        	case 1:
        	    // cqpTreeWalker.g:43:4: ^( KW_WITHIN p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) )
        	    {
        	         MATCHT(KW_WITHIN, &FOLLOW_KW_WITHIN_in_within_containing119); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_query_in_within_containing123);
        	        p=query(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        // cqpTreeWalker.g:44:13: ( NOT | )
        	        {
        	            int alt2=2;
        	            switch ( LA(1) ) 
        	            {
        	            case NOT:
        	            	{
        	            		alt2=1;
        	            	}
        	                break;
        	            case SEQ:
        	            case KW_WITHIN:
        	            case KW_CONTAINING:
        	            case ATTR:
        	            case BINOR:
        	            case BINAND:
        	            case COLON:
        	            	{
        	            		alt2=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 2;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;
        	            }

        	            switch (alt2) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:45:5: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing145); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }

        	        	        {
        	        	            within_containing_not=true;
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:47:4: 
        	        	    {
        	        	    }
        	        	    break;

        	            }
        	        }

        	        // cqpTreeWalker.g:48:13: ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] )
        	        {
        	            int alt4=2;
        	            switch ( LA(1) ) 
        	            {
        	            case SEQ:
        	            case KW_WITHIN:
        	            case KW_CONTAINING:
        	            case ATTR:
        	            case BINOR:
        	            case BINAND:
        	            	{
        	            		alt4=1;
        	            	}
        	                break;
        	            case COLON:
        	            	{
        	            		alt4=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 4;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;
        	            }

        	            switch (alt4) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:49:5: (q= structure[c] | q= query[c] )
        	        	    {

        	        	        // cqpTreeWalker.g:49:5: (q= structure[c] | q= query[c] )
        	        	        {
        	        	            int alt3=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	            case ATTR:
        	        	            	{
        	        	            		alt3=1;
        	        	            	}
        	        	                break;
        	        	            case SEQ:
        	        	            case KW_WITHIN:
        	        	            case KW_CONTAINING:
        	        	            case BINOR:
        	        	            case BINAND:
        	        	            	{
        	        	            		alt3=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 3;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulewithin_containingEx;
        	        	            }

        	        	            switch (alt3) 
        	        	            {
        	        	        	case 1:
        	        	        	    // cqpTreeWalker.g:49:7: q= structure[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_structure_in_within_containing183);
        	        	        	        q=structure(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // cqpTreeWalker.g:49:24: q= query[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_query_in_within_containing190);
        	        	        	        q=query(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:51:5: q= alignedpart[c]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_alignedpart_in_within_containing207);
        	        	        q=alignedpart(ctx, c);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        {
        	            if (within_containing_not)
        	                        q = new RQoutsideNode (q);
        	                     r=new RQinNode (p,q);
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:57:4: ^( KW_CONTAINING p= query[c] ( NOT | ) ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] ) )
        	    {
        	         MATCHT(KW_CONTAINING, &FOLLOW_KW_CONTAINING_in_within_containing237); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_query_in_within_containing241);
        	        p=query(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }


        	        // cqpTreeWalker.g:58:13: ( NOT | )
        	        {
        	            int alt5=2;
        	            switch ( LA(1) ) 
        	            {
        	            case NOT:
        	            	{
        	            		alt5=1;
        	            	}
        	                break;
        	            case SEQ:
        	            case KW_WITHIN:
        	            case KW_CONTAINING:
        	            case ATTR:
        	            case BINOR:
        	            case BINAND:
        	            case COLON:
        	            	{
        	            		alt5=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 5;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;
        	            }

        	            switch (alt5) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:59:5: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_within_containing264); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }

        	        	        {
        	        	            within_containing_not=true;
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:61:4: 
        	        	    {
        	        	    }
        	        	    break;

        	            }
        	        }

        	        // cqpTreeWalker.g:62:13: ( (q= structure[c] | q= query[c] ) | q= alignedpart[c] )
        	        {
        	            int alt7=2;
        	            switch ( LA(1) ) 
        	            {
        	            case SEQ:
        	            case KW_WITHIN:
        	            case KW_CONTAINING:
        	            case ATTR:
        	            case BINOR:
        	            case BINAND:
        	            	{
        	            		alt7=1;
        	            	}
        	                break;
        	            case COLON:
        	            	{
        	            		alt7=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 7;
        	                EXCEPTION->state        = 0;


        	                goto rulewithin_containingEx;
        	            }

        	            switch (alt7) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:63:5: (q= structure[c] | q= query[c] )
        	        	    {

        	        	        // cqpTreeWalker.g:63:5: (q= structure[c] | q= query[c] )
        	        	        {
        	        	            int alt6=2;
        	        	            switch ( LA(1) ) 
        	        	            {
        	        	            case ATTR:
        	        	            	{
        	        	            		alt6=1;
        	        	            	}
        	        	                break;
        	        	            case SEQ:
        	        	            case KW_WITHIN:
        	        	            case KW_CONTAINING:
        	        	            case BINOR:
        	        	            case BINAND:
        	        	            	{
        	        	            		alt6=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 6;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulewithin_containingEx;
        	        	            }

        	        	            switch (alt6) 
        	        	            {
        	        	        	case 1:
        	        	        	    // cqpTreeWalker.g:63:7: q= structure[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_structure_in_within_containing302);
        	        	        	        q=structure(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // cqpTreeWalker.g:63:24: q= query[c]
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_query_in_within_containing309);
        	        	        	        q=query(ctx, c);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulewithin_containingEx;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:65:5: q= alignedpart[c]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_alignedpart_in_within_containing326);
        	        	        q=alignedpart(ctx, c);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulewithin_containingEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulewithin_containingEx;
        	        }

        	        {
        	            if (within_containing_not)
        	                        q = new RQoutsideNode (q);
        	                     r=new RQcontainNode (p,q);
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulewithin_containingEx; /* Prevent compiler warnings */
    rulewithin_containingEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end within_containing */

/** 
 * $ANTLR start alignedpart
 * cqpTreeWalker.g:73:1: alignedpart[Corpus &c] returns [RangeStream *r] : ^( COLON al_name= ATTR q= bigseq[*al_corp] ) ;
 */
static RangeStream *
alignedpart(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    pANTLR3_BASE_TREE    al_name;
    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */



    	Corpus *al_corp;

    al_name       = NULL;
    q = NULL;

    {
        // cqpTreeWalker.g:77:2: ( ^( COLON al_name= ATTR q= bigseq[*al_corp] ) )
        // cqpTreeWalker.g:78:4: ^( COLON al_name= ATTR q= bigseq[*al_corp] )
        {
             MATCHT(COLON, &FOLLOW_COLON_in_alignedpart380); 
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }

            al_name = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_alignedpart384); 
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }

            {
                al_corp = c.get_aligned((const char *) (al_name->getText(al_name))->chars); al_corp->set_default_attr (c.get_default_attr()->name); 
            }
            FOLLOWPUSH(FOLLOW_bigseq_in_alignedpart398);
            q=bigseq(ctx, *al_corp);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }

            {
                r = c.map_aligned (al_corp, q);
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulealignedpartEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulealignedpartEx; /* Prevent compiler warnings */
    rulealignedpartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end alignedpart */

/** 
 * $ANTLR start globcond
 * cqpTreeWalker.g:84:1: globcond[Corpus &c] returns [RangeStream *r] : ( ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ ) | bigseq[c] );
 */
static RangeStream *
globcond(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    a1;
    pANTLR3_BASE_TREE    n2;
    pANTLR3_BASE_TREE    a2;
    pANTLR3_BASE_TREE    f;
    RangeStream * bigseq3;
    #undef	RETURN_TYPE_bigseq3
    #define	RETURN_TYPE_bigseq3 RangeStream *

    RangeStream * bigseq4;
    #undef	RETURN_TYPE_bigseq4
    #define	RETURN_TYPE_bigseq4 RangeStream *

    /* Initialize rule variables
     */



    	FastStream *a, *b; RQFilterPos::Op posOp; RQFilterFreq::Op freqOp; int neg = 0;

    n1       = NULL;
    a1       = NULL;
    n2       = NULL;
    a2       = NULL;
    f       = NULL;
    bigseq3 = NULL;
    bigseq4 = NULL;

    {
        {
            //  cqpTreeWalker.g:88:5: ( ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ ) | bigseq[c] )
            
            ANTLR3_UINT32 alt13;

            alt13=2;

            switch ( LA(1) ) 
            {
            case BINAND:
            	{
            		alt13=1;
            	}
                break;
            case SEQ:
            case BINOR:
            	{
            		alt13=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto ruleglobcondEx;
            }

            switch (alt13) 
            {
        	case 1:
        	    // cqpTreeWalker.g:89:9: ^( BINAND bigseq[c] ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+ )
        	    {
        	         MATCHT(BINAND, &FOLLOW_BINAND_in_globcond456); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_bigseq_in_globcond458);
        	        bigseq3=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }

        	        {
        	            r=bigseq3;
        	        }
        	        // cqpTreeWalker.g:90:13: ( ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR ) | ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER ) )+
        	        {
        	            int cnt12=0;

        	            for (;;)
        	            {
        	                int alt12=3;
        	        	switch ( LA(1) ) 
        	        	{
        	        	case DOT:
        	        		{
        	        			alt12=1;
        	        		}
        	        	    break;
        	        	case KW_FREQ:
        	        		{
        	        			alt12=2;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt12) 
        	        	{
        	        	    case 1:
        	        	        // cqpTreeWalker.g:90:14: ^( DOT n1= NUMBER a1= ATTR ( EQ | NOT EQ ) n2= NUMBER a2= ATTR )
        	        	        {
        	        	             MATCHT(DOT, &FOLLOW_DOT_in_globcond478); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond482); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond486); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            // cqpTreeWalker.g:91:21: ( EQ | NOT EQ )
        	        	            {
        	        	                int alt9=2;
        	        	                switch ( LA(1) ) 
        	        	                {
        	        	                case EQ:
        	        	                	{
        	        	                		alt9=1;
        	        	                	}
        	        	                    break;
        	        	                case NOT:
        	        	                	{
        	        	                		alt9=2;
        	        	                	}
        	        	                    break;

        	        	                default:
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = (void *)"";
        	        	                    EXCEPTION->decisionNum  = 9;
        	        	                    EXCEPTION->state        = 0;


        	        	                    goto ruleglobcondEx;
        	        	                }

        	        	                switch (alt9) 
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:91:22: EQ
        	        	            	    {
        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond510); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            posOp=RQFilterPos::F_EQ;
        	        	            	        }

        	        	            	    }
        	        	            	    break;
        	        	            	case 2:
        	        	            	    // cqpTreeWalker.g:92:22: NOT EQ
        	        	            	    {
        	        	            	         MATCHT(NOT, &FOLLOW_NOT_in_globcond536); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond538); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            posOp=RQFilterPos::F_NEQ;
        	        	            	        }

        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }
        	        	            n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond586); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            a2 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond590); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            {
        	        	                r= new RQFilterPos (r, c.get_attr ((const char *) (a1->getText(a1))->chars),
        	        	                                        c.get_attr ((const char *) (a2->getText(a2))->chars), posOp,
        	        	                                        atol ((const char *) (n1->getText(n1))->chars),
        	        	                                        atol ((const char *) (n2->getText(n2))->chars));
        	        	                                
        	        	            }

        	        	        }
        	        	        break;
        	        	    case 2:
        	        	        // cqpTreeWalker.g:100:5: ^( KW_FREQ n1= NUMBER a1= ATTR ( NOT )? ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT ) f= NUMBER )
        	        	        {
        	        	             MATCHT(KW_FREQ, &FOLLOW_KW_FREQ_in_globcond616); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond620); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_globcond624); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            // cqpTreeWalker.g:100:33: ( NOT )?
        	        	            {
        	        	                int alt10=2;
        	        	                switch ( LA(1) ) 
        	        	                {
        	        	                    case NOT:
        	        	                    	{
        	        	                    		alt10=1;
        	        	                    	}
        	        	                        break;
        	        	                }

        	        	                switch (alt10) 
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:100:34: NOT
        	        	            	    {
        	        	            	         MATCHT(NOT, &FOLLOW_NOT_in_globcond627); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	             neg=1; 
        	        	            	        }

        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }

        	        	            // cqpTreeWalker.g:101:6: ( EQ | LEQ | GEQ | LSTRUCT | RSTRUCT )
        	        	            {
        	        	                int alt11=5;
        	        	                switch ( LA(1) ) 
        	        	                {
        	        	                case EQ:
        	        	                	{
        	        	                		alt11=1;
        	        	                	}
        	        	                    break;
        	        	                case LEQ:
        	        	                	{
        	        	                		alt11=2;
        	        	                	}
        	        	                    break;
        	        	                case GEQ:
        	        	                	{
        	        	                		alt11=3;
        	        	                	}
        	        	                    break;
        	        	                case LSTRUCT:
        	        	                	{
        	        	                		alt11=4;
        	        	                	}
        	        	                    break;
        	        	                case RSTRUCT:
        	        	                	{
        	        	                		alt11=5;
        	        	                	}
        	        	                    break;

        	        	                default:
        	        	                    CONSTRUCTEX();
        	        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                    EXCEPTION->message      = (void *)"";
        	        	                    EXCEPTION->decisionNum  = 11;
        	        	                    EXCEPTION->state        = 0;


        	        	                    goto ruleglobcondEx;
        	        	                }

        	        	                switch (alt11) 
        	        	                {
        	        	            	case 1:
        	        	            	    // cqpTreeWalker.g:101:7: EQ
        	        	            	    {
        	        	            	         MATCHT(EQ, &FOLLOW_EQ_in_globcond639); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_EQ;
        	        	            	        }

        	        	            	    }
        	        	            	    break;
        	        	            	case 2:
        	        	            	    // cqpTreeWalker.g:102:7: LEQ
        	        	            	    {
        	        	            	         MATCHT(LEQ, &FOLLOW_LEQ_in_globcond649); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_LEQ;
        	        	            	        }

        	        	            	    }
        	        	            	    break;
        	        	            	case 3:
        	        	            	    // cqpTreeWalker.g:103:7: GEQ
        	        	            	    {
        	        	            	         MATCHT(GEQ, &FOLLOW_GEQ_in_globcond659); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_GEQ;
        	        	            	        }

        	        	            	    }
        	        	            	    break;
        	        	            	case 4:
        	        	            	    // cqpTreeWalker.g:104:7: LSTRUCT
        	        	            	    {
        	        	            	         MATCHT(LSTRUCT, &FOLLOW_LSTRUCT_in_globcond669); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_GEQ; neg=1;
        	        	            	        }

        	        	            	    }
        	        	            	    break;
        	        	            	case 5:
        	        	            	    // cqpTreeWalker.g:105:7: RSTRUCT
        	        	            	    {
        	        	            	         MATCHT(RSTRUCT, &FOLLOW_RSTRUCT_in_globcond679); 
        	        	            	        if  (HASEXCEPTION())
        	        	            	        {
        	        	            	            goto ruleglobcondEx;
        	        	            	        }

        	        	            	        {
        	        	            	            freqOp=RQFilterFreq::F_LEQ; neg=1;
        	        	            	        }

        	        	            	    }
        	        	            	    break;

        	        	                }
        	        	            }
        	        	            f = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_globcond692); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }


        	        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleglobcondEx;
        	        	            }

        	        	            {
        	        	                r= new RQFilterFreq(r, c.get_attr ((const char *) (a1->getText(a1))->chars),
        	        	                						freqOp, neg, atol ((const char *) (n1->getText(n1))->chars),
        	        	                						STR2NUMPOS ((const char *) (f->getText(f))->chars));
        	        	            }

        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt12 >= 1 )
        	        		{
        	        		    goto loop12;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleglobcondEx;
        	        	}
        	        	cnt12++;
        	            }
        	            loop12: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:113:9: bigseq[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_bigseq_in_globcond740);
        	        bigseq4=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleglobcondEx;
        	        }

        	        {
        	            r= bigseq4;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleglobcondEx; /* Prevent compiler warnings */
    ruleglobcondEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end globcond */

/** 
 * $ANTLR start structure
 * cqpTreeWalker.g:116:1: structure[Corpus &c] returns [RangeStream *r] : sn= ATTR ( | fs= onepos[*strc] ) ;
 */
static RangeStream *
structure(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    pANTLR3_BASE_TREE    sn;
    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    /* Initialize rule variables
     */



    	Structure *strc;

    sn       = NULL;
    fs = NULL;

    {
        // cqpTreeWalker.g:120:2: (sn= ATTR ( | fs= onepos[*strc] ) )
        // cqpTreeWalker.g:121:4: sn= ATTR ( | fs= onepos[*strc] )
        {
            sn = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_structure774); 
            if  (HASEXCEPTION())
            {
                goto rulestructureEx;
            }

            {
                strc = c.get_struct ((const char *) (sn->getText(sn))->chars);
            }

            // cqpTreeWalker.g:122:6: ( | fs= onepos[*strc] )
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                case UP:
                	{
                		alt14=1;
                	}
                    break;
                case ANYPOS:
                case NUMBER:
                case BINOR:
                case BINAND:
                case EQ:
                case EEQ:
                case NOT:
                case LEQ:
                case GEQ:
                	{
                		alt14=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 14;
                    EXCEPTION->state        = 0;


                    goto rulestructureEx;
                }

                switch (alt14) 
                {
            	case 1:
            	    // cqpTreeWalker.g:123:4: 
            	    {
            	        {
            	            r = strc->rng->whole();
            	        }

            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:124:8: fs= onepos[*strc]
            	    {
            	        FOLLOWPUSH(FOLLOW_onepos_in_structure801);
            	        fs=onepos(ctx, *strc);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestructureEx;
            	        }

            	        {
            	            r = strc->rng->part(fs);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestructureEx; /* Prevent compiler warnings */
    rulestructureEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end structure */

/** 
 * $ANTLR start bigseq
 * cqpTreeWalker.g:129:1: bigseq[Corpus &c] returns [RangeStream *r] : ( ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* ) | ^( BINOR p= bigseq[c] q= bigseq[c] ) );
 */
static RangeStream *
bigseq(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    RangeStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s RangeStream *

    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    RangeStream * q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RangeStream *

    /* Initialize rule variables
     */



    	r=NULL; bool usesort=false;

    s = NULL;
    fs = NULL;
    p = NULL;
    q = NULL;

    {
        {
            //  cqpTreeWalker.g:133:2: ( ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* ) | ^( BINOR p= bigseq[c] q= bigseq[c] ) )
            
            ANTLR3_UINT32 alt19;

            alt19=2;

            switch ( LA(1) ) 
            {
            case SEQ:
            	{
            		alt19=1;
            	}
                break;
            case BINOR:
            	{
            		alt19=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 19;
                EXCEPTION->state        = 0;


                goto rulebigseqEx;
            }

            switch (alt19) 
            {
        	case 1:
        	    // cqpTreeWalker.g:134:4: ^( SEQ (s= seqpart[c] )? ( (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )* )
        	    {
        	         MATCHT(SEQ, &FOLLOW_SEQ_in_bigseq840); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulebigseqEx;
        	            }


        	            // cqpTreeWalker.g:134:10: (s= seqpart[c] )?
        	            {
        	                int alt15=2;
        	                switch ( LA(1) ) 
        	                {
        	                    case LBRACKET:
        	                    	{
        	                    		alt15=1;
        	                    	}
        	                        break;
        	                }

        	                switch (alt15) 
        	                {
        	            	case 1:
        	            	    // cqpTreeWalker.g:134:11: s= seqpart[c]
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_seqpart_in_bigseq845);
        	            	        s=seqpart(ctx, c);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto rulebigseqEx;
        	            	        }

        	            	        {
        	            	            r = s;
        	            	        }

        	            	    }
        	            	    break;

        	                }
        	            }

        	            // cqpTreeWalker.g:135:4: ( (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )? )*

        	            for (;;)
        	            {
        	                int alt18=2;
        	                switch ( LA(1) ) 
        	                {
        	                case REPOPT:
        	                case SEQ:
        	                case BEGSTRUCT:
        	                case ENDSTRUCT:
        	                case WHOLESTRUCT:
        	                case KW_MEET:
        	                case KW_UNION:
        	                case KW_WITHIN:
        	                case KW_CONTAINING:
        	                case BINOR:
        	                	{
        	                		alt18=1;
        	                	}
        	                    break;

        	                }

        	                switch (alt18) 
        	                {
        	            	case 1:
        	            	    // cqpTreeWalker.g:136:5: (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) ) (p= seqpart[c] )?
        	            	    {

        	            	        // cqpTreeWalker.g:136:5: (fs= muquery[c] | p= repeat[c] | p= within_containing[c] | p= bigseq[c] | ^( BEGSTRUCT p= structure[c] ) | ^( ENDSTRUCT p= structure[c] ) | ^( WHOLESTRUCT p= structure[c] ) )
        	            	        {
        	            	            int alt16=7;
        	            	            switch ( LA(1) ) 
        	            	            {
        	            	            case KW_MEET:
        	            	            case KW_UNION:
        	            	            	{
        	            	            		alt16=1;
        	            	            	}
        	            	                break;
        	            	            case REPOPT:
        	            	            	{
        	            	            		alt16=2;
        	            	            	}
        	            	                break;
        	            	            case KW_WITHIN:
        	            	            case KW_CONTAINING:
        	            	            	{
        	            	            		alt16=3;
        	            	            	}
        	            	                break;
        	            	            case SEQ:
        	            	            case BINOR:
        	            	            	{
        	            	            		alt16=4;
        	            	            	}
        	            	                break;
        	            	            case BEGSTRUCT:
        	            	            	{
        	            	            		alt16=5;
        	            	            	}
        	            	                break;
        	            	            case ENDSTRUCT:
        	            	            	{
        	            	            		alt16=6;
        	            	            	}
        	            	                break;
        	            	            case WHOLESTRUCT:
        	            	            	{
        	            	            		alt16=7;
        	            	            	}
        	            	                break;

        	            	            default:
        	            	                CONSTRUCTEX();
        	            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            	                EXCEPTION->message      = (void *)"";
        	            	                EXCEPTION->decisionNum  = 16;
        	            	                EXCEPTION->state        = 0;


        	            	                goto rulebigseqEx;
        	            	            }

        	            	            switch (alt16) 
        	            	            {
        	            	        	case 1:
        	            	        	    // cqpTreeWalker.g:137:9: fs= muquery[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_muquery_in_bigseq874);
        	            	        	        fs=muquery(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        {
        	            	        	            p = new Pos2Range (fs, 0, 1);
        	            	        	        }

        	            	        	    }
        	            	        	    break;
        	            	        	case 2:
        	            	        	    // cqpTreeWalker.g:138:7: p= repeat[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_repeat_in_bigseq887);
        	            	        	        p=repeat(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 3:
        	            	        	    // cqpTreeWalker.g:139:7: p= within_containing[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_within_containing_in_bigseq898);
        	            	        	        p=within_containing(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 4:
        	            	        	    // cqpTreeWalker.g:140:7: p= bigseq[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq909);
        	            	        	        p=bigseq(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;
        	            	        	case 5:
        	            	        	    // cqpTreeWalker.g:141:7: ^( BEGSTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(BEGSTRUCT, &FOLLOW_BEGSTRUCT_in_bigseq919); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq923);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        {
        	            	        	            p = new Pos2Range (new BegsOfRStream (p), 0, 0);
        	            	        	        }

        	            	        	    }
        	            	        	    break;
        	            	        	case 6:
        	            	        	    // cqpTreeWalker.g:143:7: ^( ENDSTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(ENDSTRUCT, &FOLLOW_ENDSTRUCT_in_bigseq943); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq947);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        {
        	            	        	            p = new Pos2Range (new EndsOfRStream (p), 0, 0);
        	            	        	        }

        	            	        	    }
        	            	        	    break;
        	            	        	case 7:
        	            	        	    // cqpTreeWalker.g:145:7: ^( WHOLESTRUCT p= structure[c] )
        	            	        	    {
        	            	        	         MATCHT(WHOLESTRUCT, &FOLLOW_WHOLESTRUCT_in_bigseq967); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        FOLLOWPUSH(FOLLOW_structure_in_bigseq971);
        	            	        	        p=structure(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }


        	            	        	    }
        	            	        	    break;

        	            	            }
        	            	        }
        	            	        {
        	            	            if (r) {
        	            	                                    r = RQConcatNodeUnsort (r, p);
        	            	                                    usesort = true;
        	            	                                } else {
        	            	                                    r = p;
        	            	                                }
        	            	        }

        	            	        // cqpTreeWalker.g:153:5: (p= seqpart[c] )?
        	            	        {
        	            	            int alt17=2;
        	            	            switch ( LA(1) ) 
        	            	            {
        	            	                case LBRACKET:
        	            	                	{
        	            	                		alt17=1;
        	            	                	}
        	            	                    break;
        	            	            }

        	            	            switch (alt17) 
        	            	            {
        	            	        	case 1:
        	            	        	    // cqpTreeWalker.g:153:6: p= seqpart[c]
        	            	        	    {
        	            	        	        FOLLOWPUSH(FOLLOW_seqpart_in_bigseq995);
        	            	        	        p=seqpart(ctx, c);

        	            	        	        FOLLOWPOP();
        	            	        	        if  (HASEXCEPTION())
        	            	        	        {
        	            	        	            goto rulebigseqEx;
        	            	        	        }

        	            	        	        {
        	            	        	            r = RQConcatNodeUnsort (r,p); usesort=true;
        	            	        	        }

        	            	        	    }
        	            	        	    break;

        	            	            }
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop18;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop18: ; /* Jump out to here if this rule does not match */


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulebigseqEx;
        	            }

        	        }
        	        {
        	            if (usesort) r = new RQSortBeg (r);
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:160:4: ^( BINOR p= bigseq[c] q= bigseq[c] )
        	    {
        	         MATCHT(BINOR, &FOLLOW_BINOR_in_bigseq1039); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq1043);
        	        p=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_bigseq_in_bigseq1048);
        	        q=bigseq(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebigseqEx;
        	        }

        	        {
        	            r = new RQUnionNode (p,q); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulebigseqEx; /* Prevent compiler warnings */
    rulebigseqEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end bigseq */

/** 
 * $ANTLR start seqpart
 * cqpTreeWalker.g:163:1: seqpart[Corpus &c] returns [RangeStream *r] : ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )* ;
 */
static RangeStream *
seqpart(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    FastStream * res;
    #undef	RETURN_TYPE_res
    #define	RETURN_TYPE_res FastStream *

    FastStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s FastStream *

    /* Initialize rule variables
     */



    	int count = 1;

    res = NULL;
    s = NULL;

    {
        // cqpTreeWalker.g:167:2: ( ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )* )
        // cqpTreeWalker.g:168:4: ^( LBRACKET res= labeledpos[c] ) ( ^( LBRACKET s= labeledpos[c] ) )*
        {
             MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_seqpart1079); 
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }

            FOLLOWPUSH(FOLLOW_labeledpos_in_seqpart1083);
            res=labeledpos(ctx, c);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto ruleseqpartEx;
            }


            // cqpTreeWalker.g:169:3: ( ^( LBRACKET s= labeledpos[c] ) )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) ) 
                {
                case LBRACKET:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20) 
                {
            	case 1:
            	    // cqpTreeWalker.g:170:4: ^( LBRACKET s= labeledpos[c] )
            	    {
            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_seqpart1095); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_labeledpos_in_seqpart1099);
            	        s=labeledpos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleseqpartEx;
            	        }

            	        {
            	            res = new QAndNode(res, new QMoveNode (s, -count)); count++;
            	        }

            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */

            {
                r = new Pos2Range (res, 0, count);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleseqpartEx; /* Prevent compiler warnings */
    ruleseqpartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end seqpart */

/** 
 * $ANTLR start labeledpos
 * cqpTreeWalker.g:176:1: labeledpos[Corpus &c] returns [FastStream *ls] : ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) | s= onepos[c] ) ;
 */
static FastStream *
labeledpos(pcqpTreeWalker ctx, Corpus &c)
{   
    FastStream * ls = NULL;

    pANTLR3_BASE_TREE    n;
    FastStream * s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s FastStream *

    /* Initialize rule variables
     */



    	int label=0;

    n       = NULL;
    s = NULL;

    {
        // cqpTreeWalker.g:180:2: ( ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) | s= onepos[c] ) )
        // cqpTreeWalker.g:181:4: ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) | s= onepos[c] )
        {

            // cqpTreeWalker.g:181:4: ( ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) ) | s= onepos[c] )
            {
                int alt21=2;
                switch ( LA(1) ) 
                {
                case COLON:
                	{
                		alt21=1;
                	}
                    break;
                case ANYPOS:
                case NUMBER:
                case BINOR:
                case BINAND:
                case EQ:
                case EEQ:
                case NOT:
                case LEQ:
                case GEQ:
                	{
                		alt21=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 21;
                    EXCEPTION->state        = 0;


                    goto rulelabeledposEx;
                }

                switch (alt21) 
                {
            	case 1:
            	    // cqpTreeWalker.g:182:9: ^( COLON n= NUMBER ^( LBRACKET s= onepos[c] ) )
            	    {
            	         MATCHT(COLON, &FOLLOW_COLON_in_labeledpos1156); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	        n = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_labeledpos1160); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_labeledpos1163); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_onepos_in_labeledpos1167);
            	        s=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }

            	        {
            	            label = atol ((const char *) (n->getText(n))->chars);
            	        }

            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:184:9: s= onepos[c]
            	    {
            	        FOLLOWPUSH(FOLLOW_onepos_in_labeledpos1198);
            	        s=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelabeledposEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                ls = new AddLabel (s, label);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelabeledposEx; /* Prevent compiler warnings */
    rulelabeledposEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ls;
}
/* $ANTLR end labeledpos */

/** 
 * $ANTLR start repeat
 * cqpTreeWalker.g:190:1: repeat[Corpus &c] returns [RangeStream *r] : ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) ) ;
 */
static RangeStream *
repeat(pcqpTreeWalker ctx, Corpus &c)
{   
    RangeStream * r = NULL;

    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    n2;
    pANTLR3_BASE_TREE    n3;
    pANTLR3_BASE_TREE    n4;
    RangeStream * p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RangeStream *

    FastStream * fs;
    #undef	RETURN_TYPE_fs
    #define	RETURN_TYPE_fs FastStream *

    /* Initialize rule variables
     */



    	int rn1, rn2;

    n1       = NULL;
    n2       = NULL;
    n3       = NULL;
    n4       = NULL;
    p = NULL;
    fs = NULL;

    {
        // cqpTreeWalker.g:194:2: ( ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) ) )
        // cqpTreeWalker.g:195:4: ^( REPOPT (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) ) )
        {
             MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1248); 
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }


            // cqpTreeWalker.g:196:4: (p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER ) | ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER ) )
            {
                int alt22=2;
                switch ( LA(1) ) 
                {
                case SEQ:
                case KW_WITHIN:
                case KW_CONTAINING:
                case BINOR:
                case BINAND:
                	{
                		alt22=1;
                	}
                    break;
                case LBRACKET:
                	{
                		alt22=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 22;
                    EXCEPTION->state        = 0;


                    goto rulerepeatEx;
                }

                switch (alt22) 
                {
            	case 1:
            	    // cqpTreeWalker.g:197:5: p= query[c] ^( REPOPT n1= NUMBER n2= NUMBER )
            	    {
            	        FOLLOWPUSH(FOLLOW_query_in_repeat1262);
            	        p=query(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	         MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1266); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1270); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1274); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        {

            	            					rn1 = atol ((const char *) (n1->getText(n1))->chars);
            	            					rn2 = atol ((const char *) (n2->getText(n2))->chars);
            	            					if (rn1 == 0 && rn2 == 1) {
            	            						r = new RQOptionalNode (p);
            	            					} else {
            	            						r = new RQRepeatNode (p, rn1, rn2);
            	            					}
            	            				
            	        }

            	    }
            	    break;
            	case 2:
            	    // cqpTreeWalker.g:208:5: ^( LBRACKET fs= onepos[c] ) ^( REPOPT n3= NUMBER n4= NUMBER )
            	    {
            	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_repeat1293); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_onepos_in_repeat1297);
            	        fs=onepos(ctx, c);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	         MATCHT(REPOPT, &FOLLOW_REPOPT_in_repeat1302); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n3 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1306); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        n4 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_repeat1310); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerepeatEx;
            	        }

            	        {

            	            					rn1 = atol ((const char *) (n3->getText(n3))->chars);
            	            					rn2 = atol ((const char *) (n4->getText(n4))->chars);
            	            					if (rn1 == 0 && rn2 == 1) {
            	            						r = new RQOptionalNode (new Pos2Range (fs));
            	            					} else {
            	            						r = new RQRepeatFSNode (fs, rn1, rn2);
            	            					}
            	            				
            	        }

            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL); 
            if  (HASEXCEPTION())
            {
                goto rulerepeatEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulerepeatEx; /* Prevent compiler warnings */
    rulerepeatEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end repeat */

/** 
 * $ANTLR start onepos
 * cqpTreeWalker.g:223:1: onepos[Corpus &c] returns [FastStream *r] : ( ^( BINAND a= onepos[c] b= onepos[c] ) | ^( BINOR a= onepos[c] b= onepos[c] ) | ^( ( EQ | LEQ | GEQ | EEQ ) a1= ATTR ( NOT )? v1= REGEXP ) | ^( NOT a= onepos[c] ) | ^( ANYPOS () ) | ^(sn= NUMBER () ) );
 */
static FastStream *
onepos(pcqpTreeWalker ctx, Corpus &c)
{   
    FastStream * r = NULL;

    pANTLR3_BASE_TREE    a1;
    pANTLR3_BASE_TREE    v1;
    pANTLR3_BASE_TREE    sn;
    FastStream * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a FastStream *

    FastStream * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b FastStream *

    /* Initialize rule variables
     */



    	int neg = 0, cmp = 0;

    a1       = NULL;
    v1       = NULL;
    sn       = NULL;
    a = NULL;
    b = NULL;

    {
        {
            //  cqpTreeWalker.g:227:2: ( ^( BINAND a= onepos[c] b= onepos[c] ) | ^( BINOR a= onepos[c] b= onepos[c] ) | ^( ( EQ | LEQ | GEQ | EEQ ) a1= ATTR ( NOT )? v1= REGEXP ) | ^( NOT a= onepos[c] ) | ^( ANYPOS () ) | ^(sn= NUMBER () ) )
            
            ANTLR3_UINT32 alt25;

            alt25=6;

            switch ( LA(1) ) 
            {
            case BINAND:
            	{
            		alt25=1;
            	}
                break;
            case BINOR:
            	{
            		alt25=2;
            	}
                break;
            case EQ:
            case EEQ:
            case LEQ:
            case GEQ:
            	{
            		alt25=3;
            	}
                break;
            case NOT:
            	{
            		alt25=4;
            	}
                break;
            case ANYPOS:
            	{
            		alt25=5;
            	}
                break;
            case NUMBER:
            	{
            		alt25=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto ruleoneposEx;
            }

            switch (alt25) 
            {
        	case 1:
        	    // cqpTreeWalker.g:228:4: ^( BINAND a= onepos[c] b= onepos[c] )
        	    {
        	         MATCHT(BINAND, &FOLLOW_BINAND_in_onepos1354); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1358);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1363);
        	        b=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        {
        	            r = new QAndNode (a,b);
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:229:4: ^( BINOR a= onepos[c] b= onepos[c] )
        	    {
        	         MATCHT(BINOR, &FOLLOW_BINOR_in_onepos1375); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1379);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1384);
        	        b=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        {
        	            r = new QOrNode (a,b);
        	        }

        	    }
        	    break;
        	case 3:
        	    // cqpTreeWalker.g:230:4: ^( ( EQ | LEQ | GEQ | EEQ ) a1= ATTR ( NOT )? v1= REGEXP )
        	    {

        	        // cqpTreeWalker.g:230:6: ( EQ | LEQ | GEQ | EEQ )
        	        {
        	            int alt23=4;
        	            switch ( LA(1) ) 
        	            {
        	            case EQ:
        	            	{
        	            		alt23=1;
        	            	}
        	                break;
        	            case LEQ:
        	            	{
        	            		alt23=2;
        	            	}
        	                break;
        	            case GEQ:
        	            	{
        	            		alt23=3;
        	            	}
        	                break;
        	            case EEQ:
        	            	{
        	            		alt23=4;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 23;
        	                EXCEPTION->state        = 0;


        	                goto ruleoneposEx;
        	            }

        	            switch (alt23) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:230:7: EQ
        	        	    {
        	        	         MATCHT(EQ, &FOLLOW_EQ_in_onepos1395); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:230:10: LEQ
        	        	    {
        	        	         MATCHT(LEQ, &FOLLOW_LEQ_in_onepos1397); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }

        	        	        {
        	        	             cmp = -1; 
        	        	        }

        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // cqpTreeWalker.g:230:29: GEQ
        	        	    {
        	        	         MATCHT(GEQ, &FOLLOW_GEQ_in_onepos1402); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }

        	        	        {
        	        	             cmp = 1; 
        	        	        }

        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // cqpTreeWalker.g:230:46: EEQ
        	        	    {
        	        	         MATCHT(EEQ, &FOLLOW_EEQ_in_onepos1406); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }

        	        	        {
        	        	             cmp = 2; 
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        a1 = (pANTLR3_BASE_TREE) MATCHT(ATTR, &FOLLOW_ATTR_in_onepos1413); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        // cqpTreeWalker.g:230:72: ( NOT )?
        	        {
        	            int alt24=2;
        	            switch ( LA(1) ) 
        	            {
        	                case NOT:
        	                	{
        	                		alt24=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt24) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:230:73: NOT
        	        	    {
        	        	         MATCHT(NOT, &FOLLOW_NOT_in_onepos1416); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleoneposEx;
        	        	        }

        	        	        {
        	        	             neg = 1; 
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        v1 = (pANTLR3_BASE_TREE) MATCHT(REGEXP, &FOLLOW_REGEXP_in_onepos1424); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        {

        	            			if (!cmp) {
        	            				r = c.get_attr ((const char *) (a1->getText(a1))->chars)->regexp2poss ((const char *) (v1->getText(v1))->chars, false);
        	            			} else if (cmp == 2) {
        	            				PosAttr *pa = c.get_attr ((const char *) (a1->getText(a1))->chars);
        	            				r = pa->id2poss (pa->str2id ((const char *) (v1->getText(v1))->chars));
        	            			} else {
        	            				r = c.get_attr ((const char*) (a1->getText(a1))->chars)->compare2poss ((const char *) (v1->getText(v1))->chars, cmp, false);
        	            			}
        	            			if (neg) {
        	            				if (r->final() == 0) {
        	            					// empty stream
        	            					delete r;
        	            					r = new SequenceStream (0, c.size() -1, c.size());
        	            				} else {
        	            					r = new QNotNode (r, c.size());
        	            				}
        	            			}
        	            		
        	        }

        	    }
        	    break;
        	case 4:
        	    // cqpTreeWalker.g:250:7: ^( NOT a= onepos[c] )
        	    {
        	         MATCHT(NOT, &FOLLOW_NOT_in_onepos1438); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_onepos_in_onepos1442);
        	        a=onepos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }

        	        {
        	            r = new QNotNode (a, c.size());
        	        }

        	    }
        	    break;
        	case 5:
        	    // cqpTreeWalker.g:251:4: ^( ANYPOS () )
        	    {
        	         MATCHT(ANYPOS, &FOLLOW_ANYPOS_in_onepos1458); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	            // cqpTreeWalker.g:251:13: ()
        	            // cqpTreeWalker.g:251:14: 
        	            {
        	            }


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	        }
        	        {
        	            r = new SequenceStream (0, c.size() -1, c.size());
        	        }

        	    }
        	    break;
        	case 6:
        	    // cqpTreeWalker.g:252:4: ^(sn= NUMBER () )
        	    {
        	        sn = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_onepos1472); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleoneposEx;
        	        }


        	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
        	            MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	            // cqpTreeWalker.g:252:16: ()
        	            // cqpTreeWalker.g:252:17: 
        	            {
        	            }


        	            MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleoneposEx;
        	            }

        	        }
        	        {

        	            			int posnum = atol((const char *) (sn->getText(sn))->chars);
        	            			r = new SequenceStream (posnum, posnum, c.size());
        	            		
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleoneposEx; /* Prevent compiler warnings */
    ruleoneposEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end onepos */

/** 
 * $ANTLR start muquery
 * cqpTreeWalker.g:260:1: muquery[Corpus &c] returns [FastStream *r] : ( ^( KW_UNION a= mupart[c] b= mupart[c] ) | ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER | ) ) );
 */
static FastStream *
muquery(pcqpTreeWalker ctx, Corpus &c)
{   
    FastStream * r = NULL;

    pANTLR3_BASE_TREE    n1;
    pANTLR3_BASE_TREE    n2;
    FastStream * a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a FastStream *

    FastStream * b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b FastStream *

    /* Initialize rule variables
     */


    n1       = NULL;
    n2       = NULL;
    a = NULL;
    b = NULL;

    {
        {
            //  cqpTreeWalker.g:261:2: ( ^( KW_UNION a= mupart[c] b= mupart[c] ) | ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER | ) ) )
            
            ANTLR3_UINT32 alt27;

            alt27=2;

            switch ( LA(1) ) 
            {
            case KW_UNION:
            	{
            		alt27=1;
            	}
                break;
            case KW_MEET:
            	{
            		alt27=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto rulemuqueryEx;
            }

            switch (alt27) 
            {
        	case 1:
        	    // cqpTreeWalker.g:262:4: ^( KW_UNION a= mupart[c] b= mupart[c] )
        	    {
        	         MATCHT(KW_UNION, &FOLLOW_KW_UNION_in_muquery1503); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1508);
        	        a=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1513);
        	        b=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        {
        	            r = new QOrNode (a,b);
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:263:4: ^( KW_MEET a= mupart[c] b= mupart[c] (n1= NUMBER n2= NUMBER | ) )
        	    {
        	         MATCHT(KW_MEET, &FOLLOW_KW_MEET_in_muquery1523); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1527);
        	        a=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_mupart_in_muquery1532);
        	        b=mupart(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	        // cqpTreeWalker.g:264:4: (n1= NUMBER n2= NUMBER | )
        	        {
        	            int alt26=2;
        	            switch ( LA(1) ) 
        	            {
        	            case NUMBER:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;
        	            case UP:
        	            	{
        	            		alt26=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 26;
        	                EXCEPTION->state        = 0;


        	                goto rulemuqueryEx;
        	            }

        	            switch (alt26) 
        	            {
        	        	case 1:
        	        	    // cqpTreeWalker.g:264:5: n1= NUMBER n2= NUMBER
        	        	    {
        	        	        n1 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_muquery1541); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemuqueryEx;
        	        	        }

        	        	        n2 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_muquery1545); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemuqueryEx;
        	        	        }

        	        	        {

        	        	            					int i1 = atol ((const char *) (n1->getText(n1))->chars);
        	        	            					int i2 = atol ((const char *) (n2->getText(n2))->chars);
        	        	            					if (i1 == i2)
        	        	            						r = new QAndNode(a, new QMoveNode (b, -i1));
        	        	            					else
        	        	            						r = new BegsOfRStream (new RQinNode (new Pos2Range (a),
        	        	            									new Pos2Range (b, -i2, -i1+1)));
        	        	            				
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // cqpTreeWalker.g:275:5: 
        	        	    {
        	        	        {
        	        	            r = new QAndNode(a, new QMoveNode (b, -1));
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemuqueryEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemuqueryEx; /* Prevent compiler warnings */
    rulemuqueryEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end muquery */

/** 
 * $ANTLR start mupart
 * cqpTreeWalker.g:280:1: mupart[Corpus &c] returns [FastStream *r] : ( muquery[c] | ^( LBRACKET labeledpos[c] ) );
 */
static FastStream *
mupart(pcqpTreeWalker ctx, Corpus &c)
{   
    FastStream * r = NULL;

    FastStream * muquery5;
    #undef	RETURN_TYPE_muquery5
    #define	RETURN_TYPE_muquery5 FastStream *

    FastStream * labeledpos6;
    #undef	RETURN_TYPE_labeledpos6
    #define	RETURN_TYPE_labeledpos6 FastStream *

    /* Initialize rule variables
     */


    muquery5 = NULL;
    labeledpos6 = NULL;

    {
        {
            //  cqpTreeWalker.g:281:2: ( muquery[c] | ^( LBRACKET labeledpos[c] ) )
            
            ANTLR3_UINT32 alt28;

            alt28=2;

            switch ( LA(1) ) 
            {
            case KW_MEET:
            case KW_UNION:
            	{
            		alt28=1;
            	}
                break;
            case LBRACKET:
            	{
            		alt28=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto rulemupartEx;
            }

            switch (alt28) 
            {
        	case 1:
        	    // cqpTreeWalker.g:282:4: muquery[c]
        	    {
        	        FOLLOWPUSH(FOLLOW_muquery_in_mupart1591);
        	        muquery5=muquery(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }

        	        {
        	             r=muquery5; 
        	        }

        	    }
        	    break;
        	case 2:
        	    // cqpTreeWalker.g:283:4: ^( LBRACKET labeledpos[c] )
        	    {
        	         MATCHT(LBRACKET, &FOLLOW_LBRACKET_in_mupart1600); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_labeledpos_in_mupart1602);
        	        labeledpos6=labeledpos(ctx, c);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemupartEx;
        	        }

        	        {
        	            r=labeledpos6;
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulemupartEx; /* Prevent compiler warnings */
    rulemupartEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return r;
}
/* $ANTLR end mupart */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
