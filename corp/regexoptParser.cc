/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : regexopt.g
 *     -                            On : 2015-04-08 21:26:51
 *     -                for the parser : regexoptParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

    // Copyright (c) 2014-2015 Milos Jakubicek

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "regexoptParser.hh"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pregexoptParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pregexoptParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pregexoptParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pregexoptParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   regexoptParserTokenNames[36+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALNUM",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "BACKREF",
        (pANTLR3_UINT8) "BINOR",
        (pANTLR3_UINT8) "BLANK",
        (pANTLR3_UINT8) "CHARCLASS",
        (pANTLR3_UINT8) "CNTRL",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "ESC",
        (pANTLR3_UINT8) "GRAPH",
        (pANTLR3_UINT8) "LBRACE",
        (pANTLR3_UINT8) "LBRACKET",
        (pANTLR3_UINT8) "LOWER",
        (pANTLR3_UINT8) "LPAREN",
        (pANTLR3_UINT8) "NOMETA",
        (pANTLR3_UINT8) "ONE",
        (pANTLR3_UINT8) "ONEANDMORE",
        (pANTLR3_UINT8) "PLUS",
        (pANTLR3_UINT8) "PRINT",
        (pANTLR3_UINT8) "PUNCT",
        (pANTLR3_UINT8) "QUEST",
        (pANTLR3_UINT8) "RBRACE",
        (pANTLR3_UINT8) "RBRACKET",
        (pANTLR3_UINT8) "RPAREN",
        (pANTLR3_UINT8) "SEPARATOR",
        (pANTLR3_UINT8) "SPACE",
        (pANTLR3_UINT8) "SPECIAL",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "TWOANDMORE",
        (pANTLR3_UINT8) "UPPER",
        (pANTLR3_UINT8) "WS_",
        (pANTLR3_UINT8) "XDIGIT",
        (pANTLR3_UINT8) "ZEROANDMORE"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 regexoptParser_regex_return
	regex    (pregexoptParser ctx);
static 
 regexoptParser_regalt_return
	regalt    (pregexoptParser ctx);
static 
 regexoptParser_regpart_return
	regpart    (pregexoptParser ctx);
static 
 regexoptParser_regterm_return
	regterm    (pregexoptParser ctx);
static 
 regexoptParser_re_str_return
	re_str    (pregexoptParser ctx);
static 
 regexoptParser_repet_one_return
	repet_one    (pregexoptParser ctx);
static 
 regexoptParser_repet_zero_return
	repet_zero    (pregexoptParser ctx);
static void	regexoptParserFree(pregexoptParser ctx);
static void     regexoptParserReset (pregexoptParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "regexopt.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new regexoptParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pregexoptParser
regexoptParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return regexoptParserNewSSD(instream, NULL);
}

/** \brief Create a new regexoptParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pregexoptParser
regexoptParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pregexoptParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pregexoptParser) ANTLR3_CALLOC(1, sizeof(regexoptParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in regexoptParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our regexoptParser interface
     */
    ctx->regex	= regex;
    ctx->regalt	= regalt;
    ctx->regpart	= regpart;
    ctx->regterm	= regterm;
    ctx->re_str	= re_str;
    ctx->repet_one	= repet_one;
    ctx->repet_zero	= repet_zero;
    ctx->free			= regexoptParserFree;
    ctx->reset			= regexoptParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
        RECOGNIZER->displayRecognitionError = throwEvalQueryException;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = regexoptParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
regexoptParserReset (pregexoptParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 regexoptParserFree(pregexoptParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return regexoptParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regalt_in_regex975  */
static	ANTLR3_BITWORD FOLLOW_regalt_in_regex975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_regalt_in_regex975	= { FOLLOW_regalt_in_regex975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_regex978  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_regex978_bits[]	= { ANTLR3_UINT64_LIT(0x000000020030E080) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_regex978	= { FOLLOW_BINOR_in_regex978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regalt_in_regex981  */
static	ANTLR3_BITWORD FOLLOW_regalt_in_regex981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_regalt_in_regex981	= { FOLLOW_regalt_in_regex981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_regex985  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_regex985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_regex985	= { FOLLOW_EOF_in_regex985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regpart_in_regalt1003  */
static	ANTLR3_BITWORD FOLLOW_regpart_in_regalt1003_bits[]	= { ANTLR3_UINT64_LIT(0x000000020030E082) };
static  ANTLR3_BITSET_LIST FOLLOW_regpart_in_regalt1003	= { FOLLOW_regpart_in_regalt1003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regterm_in_regpart1030  */
static	ANTLR3_BITWORD FOLLOW_regterm_in_regpart1030_bits[]	= { ANTLR3_UINT64_LIT(0x0000008C09800002) };
static  ANTLR3_BITSET_LIST FOLLOW_regterm_in_regpart1030	= { FOLLOW_regterm_in_regpart1030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repet_one_in_regpart1042  */
static	ANTLR3_BITWORD FOLLOW_repet_one_in_regpart1042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_repet_one_in_regpart1042	= { FOLLOW_repet_one_in_regpart1042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TWOANDMORE_in_regpart1046  */
static	ANTLR3_BITWORD FOLLOW_TWOANDMORE_in_regpart1046_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TWOANDMORE_in_regpart1046	= { FOLLOW_TWOANDMORE_in_regpart1046_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repet_zero_in_regpart1066  */
static	ANTLR3_BITWORD FOLLOW_repet_zero_in_regpart1066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_repet_zero_in_regpart1066	= { FOLLOW_repet_zero_in_regpart1066_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_in_regterm1115  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_in_regterm1115_bits[]	= { ANTLR3_UINT64_LIT(0x000000020030E080) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_in_regterm1115	= { FOLLOW_LPAREN_in_regterm1115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regalt_in_regterm1118  */
static	ANTLR3_BITWORD FOLLOW_regalt_in_regterm1118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000100) };
static  ANTLR3_BITSET_LIST FOLLOW_regalt_in_regterm1118	= { FOLLOW_regalt_in_regterm1118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BINOR_in_regterm1121  */
static	ANTLR3_BITWORD FOLLOW_BINOR_in_regterm1121_bits[]	= { ANTLR3_UINT64_LIT(0x000000020030E080) };
static  ANTLR3_BITSET_LIST FOLLOW_BINOR_in_regterm1121	= { FOLLOW_BINOR_in_regterm1121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_regalt_in_regterm1124  */
static	ANTLR3_BITWORD FOLLOW_regalt_in_regterm1124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000100) };
static  ANTLR3_BITSET_LIST FOLLOW_regalt_in_regterm1124	= { FOLLOW_regalt_in_regterm1124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_in_regterm1128  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_in_regterm1128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_in_regterm1128	= { FOLLOW_RPAREN_in_regterm1128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_regterm1139  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_regterm1139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_regterm1139	= { FOLLOW_ENUM_in_regterm1139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_re_str_in_regterm1149  */
static	ANTLR3_BITWORD FOLLOW_re_str_in_regterm1149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_re_str_in_regterm1149	= { FOLLOW_re_str_in_regterm1149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_re_str1173  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_re_str1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_re_str1173	= { FOLLOW_DOT_in_re_str1173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BACKREF_in_re_str1175  */
static	ANTLR3_BITWORD FOLLOW_BACKREF_in_re_str1175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BACKREF_in_re_str1175	= { FOLLOW_BACKREF_in_re_str1175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPECIAL_in_re_str1177  */
static	ANTLR3_BITWORD FOLLOW_SPECIAL_in_re_str1177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SPECIAL_in_re_str1177	= { FOLLOW_SPECIAL_in_re_str1177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOMETA_in_re_str1190  */
static	ANTLR3_BITWORD FOLLOW_NOMETA_in_re_str1190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOMETA_in_re_str1190	= { FOLLOW_NOMETA_in_re_str1190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ESC_in_re_str1202  */
static	ANTLR3_BITWORD FOLLOW_ESC_in_re_str1202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ESC_in_re_str1202	= { FOLLOW_ESC_in_re_str1202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_in_repet_one1223  */
static	ANTLR3_BITWORD FOLLOW_PLUS_in_repet_one1223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_in_repet_one1223	= { FOLLOW_PLUS_in_repet_one1223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ONEANDMORE_in_repet_one1235  */
static	ANTLR3_BITWORD FOLLOW_ONEANDMORE_in_repet_one1235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ONEANDMORE_in_repet_one1235	= { FOLLOW_ONEANDMORE_in_repet_one1235_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_QUEST_in_repet_zero1256  */
static	ANTLR3_BITWORD FOLLOW_QUEST_in_repet_zero1256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_QUEST_in_repet_zero1256	= { FOLLOW_QUEST_in_repet_zero1256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_in_repet_zero1268  */
static	ANTLR3_BITWORD FOLLOW_STAR_in_repet_zero1268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_in_repet_zero1268	= { FOLLOW_STAR_in_repet_zero1268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ZEROANDMORE_in_repet_zero1280  */
static	ANTLR3_BITWORD FOLLOW_ZEROANDMORE_in_repet_zero1280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ZEROANDMORE_in_repet_zero1280	= { FOLLOW_ZEROANDMORE_in_repet_zero1280_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start regex
 * regexopt.g:122:1: regex : regalt ( BINOR ^ regalt )* EOF !;
 */
static regexoptParser_regex_return
regex(pregexoptParser ctx)
{
    regexoptParser_regex_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BINOR2;
    pANTLR3_COMMON_TOKEN    EOF4;
    regexoptParser_regalt_return regalt1;
    #undef	RETURN_TYPE_regalt1
    #define	RETURN_TYPE_regalt1 regexoptParser_regalt_return

    regexoptParser_regalt_return regalt3;
    #undef	RETURN_TYPE_regalt3
    #define	RETURN_TYPE_regalt3 regexoptParser_regalt_return

    pANTLR3_BASE_TREE BINOR2_tree;
    pANTLR3_BASE_TREE EOF4_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    BINOR2       = NULL;
    EOF4       = NULL;
    regalt1.tree = NULL;

    regalt3.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    BINOR2_tree   = NULL;
    EOF4_tree   = NULL;


    retval.tree  = NULL;

    {
        // regexopt.g:123:5: ( regalt ( BINOR ^ regalt )* EOF !)
        // regexopt.g:123:7: regalt ( BINOR ^ regalt )* EOF !
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_regalt_in_regex975);
            regalt1=regalt(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleregexEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, regalt1.tree);

            // regexopt.g:123:14: ( BINOR ^ regalt )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case BINOR:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // regexopt.g:123:15: BINOR ^ regalt
            	    {
            	        BINOR2 = (pANTLR3_COMMON_TOKEN) MATCHT(BINOR, &FOLLOW_BINOR_in_regex978);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregexEx;
            	        }

            	        BINOR2_tree = 
            	        (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BINOR2))
            	        ;
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, BINOR2_tree, root_0));


            	        FOLLOWPUSH(FOLLOW_regalt_in_regex981);
            	        regalt3=regalt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregexEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, regalt3.tree);

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            EOF4 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_regex985);
            if  (HASEXCEPTION())
            {
                goto ruleregexEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleregexEx; /* Prevent compiler warnings */
    ruleregexEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end regex */

/**
 * $ANTLR start regalt
 * regexopt.g:126:1: regalt : ( regpart )+ -> ^( AND ( regpart )+ ) ;
 */
static regexoptParser_regalt_return
regalt(pregexoptParser ctx)
{
    regexoptParser_regalt_return retval;


    pANTLR3_BASE_TREE root_0;

    regexoptParser_regpart_return regpart5;
    #undef	RETURN_TYPE_regpart5
    #define	RETURN_TYPE_regpart5 regexoptParser_regpart_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_regpart;
    /* Initialize rule variables
     */

    root_0 = NULL;

    regpart5.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_regpart   = NULL;
    #define CREATE_stream_regpart  if (stream_regpart == NULL) {stream_regpart = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule regpart"); }

    retval.tree  = NULL;

    {
        // regexopt.g:127:5: ( ( regpart )+ -> ^( AND ( regpart )+ ) )
        // regexopt.g:127:7: ( regpart )+
        {
            // regexopt.g:127:7: ( regpart )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=2;
            	switch ( LA(1) )
            	{
            	case BACKREF:
            	case DOT:
            	case ENUM:
            	case ESC:
            	case LPAREN:
            	case NOMETA:
            	case SPECIAL:
            		{
            			alt2=1;
            		}
            	    break;

            	}

            	switch (alt2)
            	{
            	    case 1:
            	        // regexopt.g:127:7: regpart
            	        {
            	            FOLLOWPUSH(FOLLOW_regpart_in_regalt1003);
            	            regpart5=regpart(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleregaltEx;
            	            }

            	            CREATE_stream_regpart; stream_regpart->add(stream_regpart, regpart5.tree, NULL);

            	        }
            	        break;

            	    default:

            		if ( cnt2 >= 1 )
            		{
            		    goto loop2;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleregaltEx;
            	}
            	cnt2++;
                }
                loop2: ;	/* Jump to here if this rule does not match */
            }

            /* AST REWRITE
             * elements          : regpart
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 127:16: -> ^( AND ( regpart )+ )
            	{
            	    // regexopt.g:127:19: ^( AND ( regpart )+ )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, AND, (pANTLR3_UINT8)"AND")
            	        , root_1));

            	        if ((stream_regpart == NULL || !stream_regpart->hasNext(stream_regpart))  )
            	        {
            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
            	        }
            	        else
            	        {
            	        	while ( (stream_regpart->hasNext(stream_regpart))  ) {
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_regpart == NULL ? NULL : stream_regpart->nextTree(stream_regpart));

            	        	}
            	        	stream_regpart->reset(stream_regpart);

            	        }
            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleregaltEx; /* Prevent compiler warnings */
    ruleregaltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_regpart != NULL) stream_regpart->free(stream_regpart);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end regalt */

/**
 * $ANTLR start regpart
 * regexopt.g:130:1: regpart : regterm ( ( repet_one | TWOANDMORE ) -> ^( ONE regterm ) | repet_zero -> SEPARATOR | -> regterm ) ;
 */
static regexoptParser_regpart_return
regpart(pregexoptParser ctx)
{
    regexoptParser_regpart_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TWOANDMORE8;
    regexoptParser_regterm_return regterm6;
    #undef	RETURN_TYPE_regterm6
    #define	RETURN_TYPE_regterm6 regexoptParser_regterm_return

    regexoptParser_repet_one_return repet_one7;
    #undef	RETURN_TYPE_repet_one7
    #define	RETURN_TYPE_repet_one7 regexoptParser_repet_one_return

    regexoptParser_repet_zero_return repet_zero9;
    #undef	RETURN_TYPE_repet_zero9
    #define	RETURN_TYPE_repet_zero9 regexoptParser_repet_zero_return

    pANTLR3_BASE_TREE TWOANDMORE8_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_TWOANDMORE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_regterm;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_repet_one;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_repet_zero;
    /* Initialize rule variables
     */

    root_0 = NULL;

    TWOANDMORE8       = NULL;
    regterm6.tree = NULL;

    repet_one7.tree = NULL;

    repet_zero9.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TWOANDMORE8_tree   = NULL;

    stream_TWOANDMORE   = NULL;
    #define CREATE_stream_TWOANDMORE  if (stream_TWOANDMORE == NULL) {stream_TWOANDMORE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token TWOANDMORE"); } 
    stream_regterm   = NULL;
    #define CREATE_stream_regterm  if (stream_regterm == NULL) {stream_regterm = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule regterm"); }
    stream_repet_one   = NULL;
    #define CREATE_stream_repet_one  if (stream_repet_one == NULL) {stream_repet_one = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule repet_one"); }
    stream_repet_zero   = NULL;
    #define CREATE_stream_repet_zero  if (stream_repet_zero == NULL) {stream_repet_zero = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule repet_zero"); }

    retval.tree  = NULL;

    {
        // regexopt.g:131:5: ( regterm ( ( repet_one | TWOANDMORE ) -> ^( ONE regterm ) | repet_zero -> SEPARATOR | -> regterm ) )
        // regexopt.g:131:7: regterm ( ( repet_one | TWOANDMORE ) -> ^( ONE regterm ) | repet_zero -> SEPARATOR | -> regterm )
        {
            FOLLOWPUSH(FOLLOW_regterm_in_regpart1030);
            regterm6=regterm(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleregpartEx;
            }

            CREATE_stream_regterm; stream_regterm->add(stream_regterm, regterm6.tree, NULL);

            // regexopt.g:132:7: ( ( repet_one | TWOANDMORE ) -> ^( ONE regterm ) | repet_zero -> SEPARATOR | -> regterm )
            {
                int alt4=3;
                switch ( LA(1) )
                {
                case ONEANDMORE:
                case PLUS:
                case TWOANDMORE:
                	{
                		alt4=1;
                	}
                    break;
                case QUEST:
                case STAR:
                case ZEROANDMORE:
                	{
                		alt4=2;
                	}
                    break;
                case EOF:
                case BACKREF:
                case BINOR:
                case DOT:
                case ENUM:
                case ESC:
                case LPAREN:
                case NOMETA:
                case RPAREN:
                case SPECIAL:
                	{
                		alt4=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 4;
                    EXCEPTION->state        = 0;


                    goto ruleregpartEx;

                }

                switch (alt4)
                {
            	case 1:
            	    // regexopt.g:132:9: ( repet_one | TWOANDMORE )
            	    {
            	        // regexopt.g:132:9: ( repet_one | TWOANDMORE )
            	        {
            	            int alt3=2;
            	            switch ( LA(1) )
            	            {
            	            case ONEANDMORE:
            	            case PLUS:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;
            	            case TWOANDMORE:
            	            	{
            	            		alt3=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 3;
            	                EXCEPTION->state        = 0;


            	                goto ruleregpartEx;

            	            }

            	            switch (alt3)
            	            {
            	        	case 1:
            	        	    // regexopt.g:132:11: repet_one
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_repet_one_in_regpart1042);
            	        	        repet_one7=repet_one(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleregpartEx;
            	        	        }

            	        	        CREATE_stream_repet_one; stream_repet_one->add(stream_repet_one, repet_one7.tree, NULL);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // regexopt.g:132:23: TWOANDMORE
            	        	    {
            	        	        TWOANDMORE8 = (pANTLR3_COMMON_TOKEN) MATCHT(TWOANDMORE, &FOLLOW_TWOANDMORE_in_regpart1046);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleregpartEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_TWOANDMORE; stream_TWOANDMORE->add(stream_TWOANDMORE, TWOANDMORE8, NULL);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        /* AST REWRITE
            	         * elements          : regterm
            	         * token labels      : 
            	         * rule labels       : retval
            	         * token list labels : 
            	         * rule list labels  : 
            	         */
            	        {
            	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        	retval.tree    = root_0;
            	        	// 132:36: -> ^( ONE regterm )
            	        	{
            	        	    // regexopt.g:132:39: ^( ONE regterm )
            	        	    {
            	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ONE, (pANTLR3_UINT8)"ONE")
            	        	        , root_1));

            	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_regterm == NULL ? NULL : stream_regterm->nextTree(stream_regterm));

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	        	    }

            	        	}


            	        	retval.tree = root_0; // set result root
            	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


            	        }
            	    }
            	    break;
            	case 2:
            	    // regexopt.g:133:9: repet_zero
            	    {
            	        FOLLOWPUSH(FOLLOW_repet_zero_in_regpart1066);
            	        repet_zero9=repet_zero(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregpartEx;
            	        }

            	        CREATE_stream_repet_zero; stream_repet_zero->add(stream_repet_zero, repet_zero9.tree, NULL);

            	        /* AST REWRITE
            	         * elements          : 
            	         * token labels      : 
            	         * rule labels       : retval
            	         * token list labels : 
            	         * rule list labels  : 
            	         */
            	        {
            	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        	retval.tree    = root_0;
            	        	// 133:20: -> SEPARATOR
            	        	{
            	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
            	        	    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SEPARATOR, (pANTLR3_UINT8)"SEPARATOR")
            	        	    );

            	        	}


            	        	retval.tree = root_0; // set result root
            	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


            	        }
            	    }
            	    break;
            	case 3:
            	    // regexopt.g:134:9: 
            	    {
            	        /* AST REWRITE
            	         * elements          : regterm
            	         * token labels      : 
            	         * rule labels       : retval
            	         * token list labels : 
            	         * rule list labels  : 
            	         */
            	        {
            	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        	retval.tree    = root_0;
            	        	// 134:9: -> regterm
            	        	{
            	        	    ADAPTOR->addChild(ADAPTOR, root_0, stream_regterm == NULL ? NULL : stream_regterm->nextTree(stream_regterm));

            	        	}


            	        	retval.tree = root_0; // set result root
            	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


            	        }
            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleregpartEx; /* Prevent compiler warnings */
    ruleregpartEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_TWOANDMORE != NULL) stream_TWOANDMORE->free(stream_TWOANDMORE);
        if (stream_regterm != NULL) stream_regterm->free(stream_regterm);
        if (stream_repet_one != NULL) stream_repet_one->free(stream_repet_one);
        if (stream_repet_zero != NULL) stream_repet_zero->free(stream_repet_zero);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end regpart */

/**
 * $ANTLR start regterm
 * regexopt.g:138:1: regterm : ( LPAREN ! regalt ( BINOR ^ regalt )* RPAREN !| ENUM | re_str ) ;
 */
static regexoptParser_regterm_return
regterm(pregexoptParser ctx)
{
    regexoptParser_regterm_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAREN10;
    pANTLR3_COMMON_TOKEN    BINOR12;
    pANTLR3_COMMON_TOKEN    RPAREN14;
    pANTLR3_COMMON_TOKEN    ENUM15;
    regexoptParser_regalt_return regalt11;
    #undef	RETURN_TYPE_regalt11
    #define	RETURN_TYPE_regalt11 regexoptParser_regalt_return

    regexoptParser_regalt_return regalt13;
    #undef	RETURN_TYPE_regalt13
    #define	RETURN_TYPE_regalt13 regexoptParser_regalt_return

    regexoptParser_re_str_return re_str16;
    #undef	RETURN_TYPE_re_str16
    #define	RETURN_TYPE_re_str16 regexoptParser_re_str_return

    pANTLR3_BASE_TREE LPAREN10_tree;
    pANTLR3_BASE_TREE BINOR12_tree;
    pANTLR3_BASE_TREE RPAREN14_tree;
    pANTLR3_BASE_TREE ENUM15_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    LPAREN10       = NULL;
    BINOR12       = NULL;
    RPAREN14       = NULL;
    ENUM15       = NULL;
    regalt11.tree = NULL;

    regalt13.tree = NULL;

    re_str16.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    LPAREN10_tree   = NULL;
    BINOR12_tree   = NULL;
    RPAREN14_tree   = NULL;
    ENUM15_tree   = NULL;


    retval.tree  = NULL;

    {
        // regexopt.g:139:5: ( ( LPAREN ! regalt ( BINOR ^ regalt )* RPAREN !| ENUM | re_str ) )
        // regexopt.g:140:5: ( LPAREN ! regalt ( BINOR ^ regalt )* RPAREN !| ENUM | re_str )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // regexopt.g:140:5: ( LPAREN ! regalt ( BINOR ^ regalt )* RPAREN !| ENUM | re_str )
            {
                int alt6=3;
                switch ( LA(1) )
                {
                case LPAREN:
                	{
                		alt6=1;
                	}
                    break;
                case ENUM:
                	{
                		alt6=2;
                	}
                    break;
                case BACKREF:
                case DOT:
                case ESC:
                case NOMETA:
                case SPECIAL:
                	{
                		alt6=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 6;
                    EXCEPTION->state        = 0;


                    goto ruleregtermEx;

                }

                switch (alt6)
                {
            	case 1:
            	    // regexopt.g:140:9: LPAREN ! regalt ( BINOR ^ regalt )* RPAREN !
            	    {
            	        LPAREN10 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAREN, &FOLLOW_LPAREN_in_regterm1115);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregtermEx;
            	        }


            	        FOLLOWPUSH(FOLLOW_regalt_in_regterm1118);
            	        regalt11=regalt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregtermEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, regalt11.tree);

            	        // regexopt.g:140:24: ( BINOR ^ regalt )*

            	        for (;;)
            	        {
            	            int alt5=2;
            	            switch ( LA(1) )
            	            {
            	            case BINOR:
            	            	{
            	            		alt5=1;
            	            	}
            	                break;

            	            }

            	            switch (alt5)
            	            {
            	        	case 1:
            	        	    // regexopt.g:140:25: BINOR ^ regalt
            	        	    {
            	        	        BINOR12 = (pANTLR3_COMMON_TOKEN) MATCHT(BINOR, &FOLLOW_BINOR_in_regterm1121);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleregtermEx;
            	        	        }

            	        	        BINOR12_tree = 
            	        	        (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BINOR12))
            	        	        ;
            	        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, BINOR12_tree, root_0));


            	        	        FOLLOWPUSH(FOLLOW_regalt_in_regterm1124);
            	        	        regalt13=regalt(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleregtermEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, regalt13.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop5;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop5: ; /* Jump out to here if this rule does not match */


            	        RPAREN14 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAREN, &FOLLOW_RPAREN_in_regterm1128);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregtermEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // regexopt.g:141:9: ENUM
            	    {
            	        ENUM15 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUM, &FOLLOW_ENUM_in_regterm1139);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregtermEx;
            	        }

            	        ENUM15_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENUM15));
            	        ADAPTOR->addChild(ADAPTOR, root_0, ENUM15_tree);


            	    }
            	    break;
            	case 3:
            	    // regexopt.g:142:9: re_str
            	    {
            	        FOLLOWPUSH(FOLLOW_re_str_in_regterm1149);
            	        re_str16=re_str(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleregtermEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, re_str16.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleregtermEx; /* Prevent compiler warnings */
    ruleregtermEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end regterm */

/**
 * $ANTLR start re_str
 * regexopt.g:146:1: re_str : ( ( DOT | BACKREF | SPECIAL ) -> SEPARATOR | NOMETA -> NOMETA | ESC -> ESC );
 */
static regexoptParser_re_str_return
re_str(pregexoptParser ctx)
{
    regexoptParser_re_str_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT17;
    pANTLR3_COMMON_TOKEN    BACKREF18;
    pANTLR3_COMMON_TOKEN    SPECIAL19;
    pANTLR3_COMMON_TOKEN    NOMETA20;
    pANTLR3_COMMON_TOKEN    ESC21;

    pANTLR3_BASE_TREE DOT17_tree;
    pANTLR3_BASE_TREE BACKREF18_tree;
    pANTLR3_BASE_TREE SPECIAL19_tree;
    pANTLR3_BASE_TREE NOMETA20_tree;
    pANTLR3_BASE_TREE ESC21_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_SPECIAL;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_DOT;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_BACKREF;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ESC;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NOMETA;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DOT17       = NULL;
    BACKREF18       = NULL;
    SPECIAL19       = NULL;
    NOMETA20       = NULL;
    ESC21       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DOT17_tree   = NULL;
    BACKREF18_tree   = NULL;
    SPECIAL19_tree   = NULL;
    NOMETA20_tree   = NULL;
    ESC21_tree   = NULL;

    stream_SPECIAL   = NULL;
    #define CREATE_stream_SPECIAL  if (stream_SPECIAL == NULL) {stream_SPECIAL = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token SPECIAL"); } 
    stream_DOT   = NULL;
    #define CREATE_stream_DOT  if (stream_DOT == NULL) {stream_DOT = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token DOT"); } 
    stream_BACKREF   = NULL;
    #define CREATE_stream_BACKREF  if (stream_BACKREF == NULL) {stream_BACKREF = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token BACKREF"); } 
    stream_ESC   = NULL;
    #define CREATE_stream_ESC  if (stream_ESC == NULL) {stream_ESC = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ESC"); } 
    stream_NOMETA   = NULL;
    #define CREATE_stream_NOMETA  if (stream_NOMETA == NULL) {stream_NOMETA = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NOMETA"); } 

    retval.tree  = NULL;

    {
        {
            //  regexopt.g:147:5: ( ( DOT | BACKREF | SPECIAL ) -> SEPARATOR | NOMETA -> NOMETA | ESC -> ESC )

            ANTLR3_UINT32 alt8;

            alt8=3;

            switch ( LA(1) )
            {
            case BACKREF:
            case DOT:
            case SPECIAL:
            	{
            		alt8=1;
            	}
                break;
            case NOMETA:
            	{
            		alt8=2;
            	}
                break;
            case ESC:
            	{
            		alt8=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulere_strEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // regexopt.g:147:7: ( DOT | BACKREF | SPECIAL )
        	    {
        	        // regexopt.g:147:7: ( DOT | BACKREF | SPECIAL )
        	        {
        	            int alt7=3;
        	            switch ( LA(1) )
        	            {
        	            case DOT:
        	            	{
        	            		alt7=1;
        	            	}
        	                break;
        	            case BACKREF:
        	            	{
        	            		alt7=2;
        	            	}
        	                break;
        	            case SPECIAL:
        	            	{
        	            		alt7=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 7;
        	                EXCEPTION->state        = 0;


        	                goto rulere_strEx;

        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // regexopt.g:147:8: DOT
        	        	    {
        	        	        DOT17 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_re_str1173);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulere_strEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_DOT; stream_DOT->add(stream_DOT, DOT17, NULL);


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // regexopt.g:147:12: BACKREF
        	        	    {
        	        	        BACKREF18 = (pANTLR3_COMMON_TOKEN) MATCHT(BACKREF, &FOLLOW_BACKREF_in_re_str1175);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulere_strEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_BACKREF; stream_BACKREF->add(stream_BACKREF, BACKREF18, NULL);


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // regexopt.g:147:20: SPECIAL
        	        	    {
        	        	        SPECIAL19 = (pANTLR3_COMMON_TOKEN) MATCHT(SPECIAL, &FOLLOW_SPECIAL_in_re_str1177);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulere_strEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_SPECIAL; stream_SPECIAL->add(stream_SPECIAL, SPECIAL19, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : 
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 147:29: -> SEPARATOR
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, SEPARATOR, (pANTLR3_UINT8)"SEPARATOR")
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // regexopt.g:148:7: NOMETA
        	    {
        	        NOMETA20 = (pANTLR3_COMMON_TOKEN) MATCHT(NOMETA, &FOLLOW_NOMETA_in_re_str1190);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulere_strEx;
        	        }
        	         
        	        CREATE_stream_NOMETA; stream_NOMETA->add(stream_NOMETA, NOMETA20, NULL);


        	        /* AST REWRITE
        	         * elements          : NOMETA
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 148:14: -> NOMETA
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_NOMETA == NULL ? NULL : stream_NOMETA->nextNode(stream_NOMETA)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // regexopt.g:149:7: ESC
        	    {
        	        ESC21 = (pANTLR3_COMMON_TOKEN) MATCHT(ESC, &FOLLOW_ESC_in_re_str1202);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulere_strEx;
        	        }
        	         
        	        CREATE_stream_ESC; stream_ESC->add(stream_ESC, ESC21, NULL);


        	        /* AST REWRITE
        	         * elements          : ESC
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 149:11: -> ESC
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_ESC == NULL ? NULL : stream_ESC->nextNode(stream_ESC)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulere_strEx; /* Prevent compiler warnings */
    rulere_strEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_SPECIAL != NULL) stream_SPECIAL->free(stream_SPECIAL);
        if (stream_DOT != NULL) stream_DOT->free(stream_DOT);
        if (stream_BACKREF != NULL) stream_BACKREF->free(stream_BACKREF);
        if (stream_ESC != NULL) stream_ESC->free(stream_ESC);
        if (stream_NOMETA != NULL) stream_NOMETA->free(stream_NOMETA);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end re_str */

/**
 * $ANTLR start repet_one
 * regexopt.g:152:1: repet_one : ( PLUS -> PLUS | ONEANDMORE -> ONEANDMORE );
 */
static regexoptParser_repet_one_return
repet_one(pregexoptParser ctx)
{
    regexoptParser_repet_one_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    PLUS22;
    pANTLR3_COMMON_TOKEN    ONEANDMORE23;

    pANTLR3_BASE_TREE PLUS22_tree;
    pANTLR3_BASE_TREE ONEANDMORE23_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_PLUS;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ONEANDMORE;

    /* Initialize rule variables
     */

    root_0 = NULL;

    PLUS22       = NULL;
    ONEANDMORE23       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    PLUS22_tree   = NULL;
    ONEANDMORE23_tree   = NULL;

    stream_PLUS   = NULL;
    #define CREATE_stream_PLUS  if (stream_PLUS == NULL) {stream_PLUS = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token PLUS"); } 
    stream_ONEANDMORE   = NULL;
    #define CREATE_stream_ONEANDMORE  if (stream_ONEANDMORE == NULL) {stream_ONEANDMORE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ONEANDMORE"); } 

    retval.tree  = NULL;

    {
        {
            //  regexopt.g:153:5: ( PLUS -> PLUS | ONEANDMORE -> ONEANDMORE )

            ANTLR3_UINT32 alt9;

            alt9=2;

            switch ( LA(1) )
            {
            case PLUS:
            	{
            		alt9=1;
            	}
                break;
            case ONEANDMORE:
            	{
            		alt9=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulerepet_oneEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // regexopt.g:153:7: PLUS
        	    {
        	        PLUS22 = (pANTLR3_COMMON_TOKEN) MATCHT(PLUS, &FOLLOW_PLUS_in_repet_one1223);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerepet_oneEx;
        	        }
        	         
        	        CREATE_stream_PLUS; stream_PLUS->add(stream_PLUS, PLUS22, NULL);


        	        /* AST REWRITE
        	         * elements          : PLUS
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 153:12: -> PLUS
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_PLUS == NULL ? NULL : stream_PLUS->nextNode(stream_PLUS)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // regexopt.g:154:7: ONEANDMORE
        	    {
        	        ONEANDMORE23 = (pANTLR3_COMMON_TOKEN) MATCHT(ONEANDMORE, &FOLLOW_ONEANDMORE_in_repet_one1235);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerepet_oneEx;
        	        }
        	         
        	        CREATE_stream_ONEANDMORE; stream_ONEANDMORE->add(stream_ONEANDMORE, ONEANDMORE23, NULL);


        	        /* AST REWRITE
        	         * elements          : ONEANDMORE
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 154:18: -> ONEANDMORE
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_ONEANDMORE == NULL ? NULL : stream_ONEANDMORE->nextNode(stream_ONEANDMORE)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerepet_oneEx; /* Prevent compiler warnings */
    rulerepet_oneEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_PLUS != NULL) stream_PLUS->free(stream_PLUS);
        if (stream_ONEANDMORE != NULL) stream_ONEANDMORE->free(stream_ONEANDMORE);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end repet_one */

/**
 * $ANTLR start repet_zero
 * regexopt.g:157:1: repet_zero : ( QUEST -> QUEST | STAR -> STAR | ZEROANDMORE -> ZEROANDMORE );
 */
static regexoptParser_repet_zero_return
repet_zero(pregexoptParser ctx)
{
    regexoptParser_repet_zero_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    QUEST24;
    pANTLR3_COMMON_TOKEN    STAR25;
    pANTLR3_COMMON_TOKEN    ZEROANDMORE26;

    pANTLR3_BASE_TREE QUEST24_tree;
    pANTLR3_BASE_TREE STAR25_tree;
    pANTLR3_BASE_TREE ZEROANDMORE26_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STAR;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ZEROANDMORE;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_QUEST;

    /* Initialize rule variables
     */

    root_0 = NULL;

    QUEST24       = NULL;
    STAR25       = NULL;
    ZEROANDMORE26       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    QUEST24_tree   = NULL;
    STAR25_tree   = NULL;
    ZEROANDMORE26_tree   = NULL;

    stream_STAR   = NULL;
    #define CREATE_stream_STAR  if (stream_STAR == NULL) {stream_STAR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STAR"); } 
    stream_ZEROANDMORE   = NULL;
    #define CREATE_stream_ZEROANDMORE  if (stream_ZEROANDMORE == NULL) {stream_ZEROANDMORE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ZEROANDMORE"); } 
    stream_QUEST   = NULL;
    #define CREATE_stream_QUEST  if (stream_QUEST == NULL) {stream_QUEST = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token QUEST"); } 

    retval.tree  = NULL;

    {
        {
            //  regexopt.g:158:5: ( QUEST -> QUEST | STAR -> STAR | ZEROANDMORE -> ZEROANDMORE )

            ANTLR3_UINT32 alt10;

            alt10=3;

            switch ( LA(1) )
            {
            case QUEST:
            	{
            		alt10=1;
            	}
                break;
            case STAR:
            	{
            		alt10=2;
            	}
                break;
            case ZEROANDMORE:
            	{
            		alt10=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulerepet_zeroEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // regexopt.g:158:7: QUEST
        	    {
        	        QUEST24 = (pANTLR3_COMMON_TOKEN) MATCHT(QUEST, &FOLLOW_QUEST_in_repet_zero1256);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerepet_zeroEx;
        	        }
        	         
        	        CREATE_stream_QUEST; stream_QUEST->add(stream_QUEST, QUEST24, NULL);


        	        /* AST REWRITE
        	         * elements          : QUEST
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 158:13: -> QUEST
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_QUEST == NULL ? NULL : stream_QUEST->nextNode(stream_QUEST)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // regexopt.g:159:7: STAR
        	    {
        	        STAR25 = (pANTLR3_COMMON_TOKEN) MATCHT(STAR, &FOLLOW_STAR_in_repet_zero1268);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerepet_zeroEx;
        	        }
        	         
        	        CREATE_stream_STAR; stream_STAR->add(stream_STAR, STAR25, NULL);


        	        /* AST REWRITE
        	         * elements          : STAR
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 159:12: -> STAR
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_STAR == NULL ? NULL : stream_STAR->nextNode(stream_STAR)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // regexopt.g:160:7: ZEROANDMORE
        	    {
        	        ZEROANDMORE26 = (pANTLR3_COMMON_TOKEN) MATCHT(ZEROANDMORE, &FOLLOW_ZEROANDMORE_in_repet_zero1280);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerepet_zeroEx;
        	        }
        	         
        	        CREATE_stream_ZEROANDMORE; stream_ZEROANDMORE->add(stream_ZEROANDMORE, ZEROANDMORE26, NULL);


        	        /* AST REWRITE
        	         * elements          : ZEROANDMORE
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 160:19: -> ZEROANDMORE
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    stream_ZEROANDMORE == NULL ? NULL : stream_ZEROANDMORE->nextNode(stream_ZEROANDMORE)
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerepet_zeroEx; /* Prevent compiler warnings */
    rulerepet_zeroEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_STAR != NULL) stream_STAR->free(stream_STAR);
        if (stream_ZEROANDMORE != NULL) stream_ZEROANDMORE->free(stream_ZEROANDMORE);
        if (stream_QUEST != NULL) stream_QUEST->free(stream_QUEST);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end repet_zero */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
