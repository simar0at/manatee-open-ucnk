/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : regexopt.g
 *     -                            On : 2015-04-08 21:26:52
 *     -                 for the lexer : regexoptLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

    // Copyright (c) 2014-2015 Milos Jakubicek

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "regexoptLexer.hh"
/* ----------------------------------------- */


/** String literals used by regexoptLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x5B, 0x3A, 0x61, 0x6C, 0x6E, 0x75, 0x6D, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x5B, 0x3A, 0x61, 0x6C, 0x70, 0x68, 0x61, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x5B, 0x3A, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x5B, 0x3A, 0x63, 0x6E, 0x74, 0x72, 0x6C, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x5B, 0x3A, 0x64, 0x69, 0x67, 0x69, 0x74, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x5B, 0x3A, 0x67, 0x72, 0x61, 0x70, 0x68, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x5B, 0x3A, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x5B, 0x3A, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x5B, 0x3A, 0x70, 0x75, 0x6E, 0x63, 0x74, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x5B, 0x3A, 0x73, 0x70, 0x61, 0x63, 0x65, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x5B, 0x3A, 0x75, 0x70, 0x70, 0x65, 0x72, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x5B, 0x3A, 0x78, 0x64, 0x69, 0x67, 0x69, 0x74, 0x3A, 0x5D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x7B, 0x30,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x7B, 0x30, 0x2C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x7B, 0x2C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x7B, 0x31,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x7B, 0x31, 0x2C,  ANTLR3_STRING_TERMINATOR};





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pregexoptLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pregexoptLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pregexoptLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pregexoptLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER
#undef	    RULEMEMO
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE 
 void
	mALNUM    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mALPHA    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mBLANK    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mCNTRL    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mDIGIT    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mGRAPH    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mLOWER    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mPRINT    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mPUNCT    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mSPACE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mUPPER    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mXDIGIT    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mWS_    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mLPAREN    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mRPAREN    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mLBRACKET    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mRBRACKET    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mLBRACE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mRBRACE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mBINOR    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mSTAR    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mPLUS    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mQUEST    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mDOT    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mZEROANDMORE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mONEANDMORE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mTWOANDMORE    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mESC    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mBACKREF    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mSPECIAL    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mNOMETA    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mENUM    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mCHARCLASS    (pregexoptLexer ctx);
static ANTLR3_INLINE 
 void
	mTokens    (pregexoptLexer ctx);
static void	regexoptLexerFree(pregexoptLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
regexoptLexerFree  (pregexoptLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
regexoptLexerReset (pregexoptLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "regexopt.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called regexoptLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pregexoptLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pregexoptLexer regexoptLexerNew
(
pANTLR3_INPUT_STREAM
 instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return regexoptLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called regexoptLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pregexoptLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pregexoptLexer regexoptLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pregexoptLexer ctx; // Context structure we will build and return

    ctx = (pregexoptLexer) ANTLR3_CALLOC(1, sizeof(regexoptLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in regexoptLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our regexoptLexer interface
     */
    ctx->mALNUM	= mALNUM;
    ctx->mALPHA	= mALPHA;
    ctx->mBLANK	= mBLANK;
    ctx->mCNTRL	= mCNTRL;
    ctx->mDIGIT	= mDIGIT;
    ctx->mGRAPH	= mGRAPH;
    ctx->mLOWER	= mLOWER;
    ctx->mPRINT	= mPRINT;
    ctx->mPUNCT	= mPUNCT;
    ctx->mSPACE	= mSPACE;
    ctx->mUPPER	= mUPPER;
    ctx->mXDIGIT	= mXDIGIT;
    ctx->mWS_	= mWS_;
    ctx->mLPAREN	= mLPAREN;
    ctx->mRPAREN	= mRPAREN;
    ctx->mLBRACKET	= mLBRACKET;
    ctx->mRBRACKET	= mRBRACKET;
    ctx->mLBRACE	= mLBRACE;
    ctx->mRBRACE	= mRBRACE;
    ctx->mBINOR	= mBINOR;
    ctx->mSTAR	= mSTAR;
    ctx->mPLUS	= mPLUS;
    ctx->mQUEST	= mQUEST;
    ctx->mDOT	= mDOT;
    ctx->mZEROANDMORE	= mZEROANDMORE;
    ctx->mONEANDMORE	= mONEANDMORE;
    ctx->mTWOANDMORE	= mTWOANDMORE;
    ctx->mESC	= mESC;
    ctx->mBACKREF	= mBACKREF;
    ctx->mSPECIAL	= mSPECIAL;
    ctx->mNOMETA	= mNOMETA;
    ctx->mENUM	= mENUM;
    ctx->mCHARCLASS	= mCHARCLASS;
    ctx->mTokens	= mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= regexoptLexerFree;
    ctx->reset          = regexoptLexerReset;


	     RECOGNIZER->displayRecognitionError = throwEvalQueryException;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    104:1: TWOANDMORE : ( '{' ( '2' .. '9' ) ( '0' .. '9' )* ( ',' )? '}' | '{' ( '2' .. '9' ) ( '0' .. '9' )* ',' ( '0' .. '9' )+ '}' | '{1' ( '0' .. '9' )+ ( ',' )? '}' | '{1' ( '0' .. '9' )+ ',' ( '0' .. '9' )+ '}' );
 */
static const ANTLR3_INT32 dfa16_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa16_eof[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa16_min[12] =
    {
	123, 49, 44, 48, 44, 48, -1, 44, -1, 48, -1, -1
    };
static const ANTLR3_INT32 dfa16_max[12] =
    {
	123, 57, 125, 57, 125, 125, -1, 125, -1, 125, -1, -1
    };
static const ANTLR3_INT32 dfa16_accept[12] =
    {
	-1, -1, -1, -1, -1, -1, 1, -1, 2, -1, 3, 4
    };
static const ANTLR3_INT32 dfa16_special[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa16_T_empty	    NULL

static const ANTLR3_INT32 dfa16_T0[] =
    {
	1
    };
static const ANTLR3_INT32 dfa16_T1[] =
    {
	8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 6
    };
static const ANTLR3_INT32 dfa16_T2[] =
    {
	3, 2, 2, 2, 2, 2, 2, 2, 2
    };
static const ANTLR3_INT32 dfa16_T3[] =
    {
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7
    };
static const ANTLR3_INT32 dfa16_T4[] =
    {
	5, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 6
    };
static const ANTLR3_INT32 dfa16_T5[] =
    {
	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 10
    };
static const ANTLR3_INT32 dfa16_T6[] =
    {
	9, -1, -1, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 10
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa16_transitions[] =
{
    dfa16_T0, dfa16_T2, dfa16_T4, dfa16_T3, dfa16_T4, dfa16_T1, NULL, dfa16_T6, 
    NULL, dfa16_T5, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 16
 */
static
ANTLR3_CYCLIC_DFA cdfa16
    =	{
	    16,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"104:1: TWOANDMORE : ( '{' ( '2' .. '9' ) ( '0' .. '9' )* ( ',' )? '}' | '{' ( '2' .. '9' ) ( '0' .. '9' )* ',' ( '0' .. '9' )+ '}' | '{1' ( '0' .. '9' )+ ( ',' )? '}' | '{1' ( '0' .. '9' )+ ',' ( '0' .. '9' )+ '}' );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa16_eot,	    /* EOT table			    */
	    dfa16_eof,	    /* EOF table			    */
	    dfa16_min,	    /* Minimum tokens for each state    */
	    dfa16_max,	    /* Maximum tokens for each state    */
	    dfa16_accept,	/* Accept table			    */
	    dfa16_special,	/* Special transition states	    */
	    dfa16_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 16
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 18:7: ( '[:alnum:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALNUM
 *
 * Looks to match the characters the constitute the token ALNUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALNUM(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALNUM;


    // regexopt.g:18:7: ( '[:alnum:]' )
    // regexopt.g:18:9: '[:alnum:]'
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION())
        {
            goto ruleALNUMEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALNUMEx; /* Prevent compiler warnings */
    ruleALNUMEx: ;

}
// $ANTLR end ALNUM

//   Comes from: 19:7: ( '[:alpha:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALPHA
 *
 * Looks to match the characters the constitute the token ALPHA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mALPHA(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ALPHA;


    // regexopt.g:19:7: ( '[:alpha:]' )
    // regexopt.g:19:9: '[:alpha:]'
    {
        MATCHS(lit_2);
        if  (HASEXCEPTION())
        {
            goto ruleALPHAEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleALPHAEx; /* Prevent compiler warnings */
    ruleALPHAEx: ;

}
// $ANTLR end ALPHA

//   Comes from: 20:7: ( '[:blank:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BLANK
 *
 * Looks to match the characters the constitute the token BLANK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBLANK(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BLANK;


    // regexopt.g:20:7: ( '[:blank:]' )
    // regexopt.g:20:9: '[:blank:]'
    {
        MATCHS(lit_3);
        if  (HASEXCEPTION())
        {
            goto ruleBLANKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBLANKEx; /* Prevent compiler warnings */
    ruleBLANKEx: ;

}
// $ANTLR end BLANK

//   Comes from: 21:7: ( '[:cntrl:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CNTRL
 *
 * Looks to match the characters the constitute the token CNTRL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCNTRL(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CNTRL;


    // regexopt.g:21:7: ( '[:cntrl:]' )
    // regexopt.g:21:9: '[:cntrl:]'
    {
        MATCHS(lit_4);
        if  (HASEXCEPTION())
        {
            goto ruleCNTRLEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCNTRLEx; /* Prevent compiler warnings */
    ruleCNTRLEx: ;

}
// $ANTLR end CNTRL

//   Comes from: 22:7: ( '[:digit:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DIGIT;


    // regexopt.g:22:7: ( '[:digit:]' )
    // regexopt.g:22:9: '[:digit:]'
    {
        MATCHS(lit_5);
        if  (HASEXCEPTION())
        {
            goto ruleDIGITEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 23:7: ( '[:graph:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GRAPH
 *
 * Looks to match the characters the constitute the token GRAPH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGRAPH(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GRAPH;


    // regexopt.g:23:7: ( '[:graph:]' )
    // regexopt.g:23:9: '[:graph:]'
    {
        MATCHS(lit_6);
        if  (HASEXCEPTION())
        {
            goto ruleGRAPHEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGRAPHEx; /* Prevent compiler warnings */
    ruleGRAPHEx: ;

}
// $ANTLR end GRAPH

//   Comes from: 24:7: ( '[:lower:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOWER
 *
 * Looks to match the characters the constitute the token LOWER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOWER(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LOWER;


    // regexopt.g:24:7: ( '[:lower:]' )
    // regexopt.g:24:9: '[:lower:]'
    {
        MATCHS(lit_7);
        if  (HASEXCEPTION())
        {
            goto ruleLOWEREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLOWEREx; /* Prevent compiler warnings */
    ruleLOWEREx: ;

}
// $ANTLR end LOWER

//   Comes from: 25:7: ( '[:print:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRINT
 *
 * Looks to match the characters the constitute the token PRINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRINT(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PRINT;


    // regexopt.g:25:7: ( '[:print:]' )
    // regexopt.g:25:9: '[:print:]'
    {
        MATCHS(lit_8);
        if  (HASEXCEPTION())
        {
            goto rulePRINTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePRINTEx; /* Prevent compiler warnings */
    rulePRINTEx: ;

}
// $ANTLR end PRINT

//   Comes from: 26:7: ( '[:punct:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PUNCT
 *
 * Looks to match the characters the constitute the token PUNCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPUNCT(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PUNCT;


    // regexopt.g:26:7: ( '[:punct:]' )
    // regexopt.g:26:9: '[:punct:]'
    {
        MATCHS(lit_9);
        if  (HASEXCEPTION())
        {
            goto rulePUNCTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePUNCTEx; /* Prevent compiler warnings */
    rulePUNCTEx: ;

}
// $ANTLR end PUNCT

//   Comes from: 27:7: ( '[:space:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPACE
 *
 * Looks to match the characters the constitute the token SPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSPACE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SPACE;


    // regexopt.g:27:7: ( '[:space:]' )
    // regexopt.g:27:9: '[:space:]'
    {
        MATCHS(lit_10);
        if  (HASEXCEPTION())
        {
            goto ruleSPACEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSPACEEx; /* Prevent compiler warnings */
    ruleSPACEEx: ;

}
// $ANTLR end SPACE

//   Comes from: 28:7: ( '[:upper:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UPPER
 *
 * Looks to match the characters the constitute the token UPPER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUPPER(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UPPER;


    // regexopt.g:28:7: ( '[:upper:]' )
    // regexopt.g:28:9: '[:upper:]'
    {
        MATCHS(lit_11);
        if  (HASEXCEPTION())
        {
            goto ruleUPPEREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUPPEREx; /* Prevent compiler warnings */
    ruleUPPEREx: ;

}
// $ANTLR end UPPER

//   Comes from: 29:8: ( '[:xdigit:]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start XDIGIT
 *
 * Looks to match the characters the constitute the token XDIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mXDIGIT(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = XDIGIT;


    // regexopt.g:29:8: ( '[:xdigit:]' )
    // regexopt.g:29:10: '[:xdigit:]'
    {
        MATCHS(lit_12);
        if  (HASEXCEPTION())
        {
            goto ruleXDIGITEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleXDIGITEx; /* Prevent compiler warnings */
    ruleXDIGITEx: ;

}
// $ANTLR end XDIGIT

//   Comes from: 83:5: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS_
 *
 * Looks to match the characters the constitute the token WS_
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS_(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS_;


    // regexopt.g:83:5: ( ( ' ' | '\\t' | '\\n' | '\\r' ) )
    // regexopt.g:83:9: ( ' ' | '\\t' | '\\n' | '\\r' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleWS_Ex;
        }


        {
             SKIP(); 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWS_Ex; /* Prevent compiler warnings */
    ruleWS_Ex: ;

}
// $ANTLR end WS_

//   Comes from: 90:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAREN
 *
 * Looks to match the characters the constitute the token LPAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLPAREN(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LPAREN;


    // regexopt.g:90:7: ( '(' )
    // regexopt.g:90:14: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleLPARENEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLPARENEx; /* Prevent compiler warnings */
    ruleLPARENEx: ;

}
// $ANTLR end LPAREN

//   Comes from: 91:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAREN
 *
 * Looks to match the characters the constitute the token RPAREN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRPAREN(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RPAREN;


    // regexopt.g:91:7: ( ')' )
    // regexopt.g:91:14: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleRPARENEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRPARENEx; /* Prevent compiler warnings */
    ruleRPARENEx: ;

}
// $ANTLR end RPAREN

//   Comes from: 92:9: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LBRACKET
 *
 * Looks to match the characters the constitute the token LBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLBRACKET(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LBRACKET;


    // regexopt.g:92:9: ( '[' )
    // regexopt.g:92:14: '['
    {
        MATCHC('[');
        if  (HASEXCEPTION())
        {
            goto ruleLBRACKETEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLBRACKETEx; /* Prevent compiler warnings */
    ruleLBRACKETEx: ;

}
// $ANTLR end LBRACKET

//   Comes from: 93:9: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RBRACKET
 *
 * Looks to match the characters the constitute the token RBRACKET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRBRACKET(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RBRACKET;


    // regexopt.g:93:9: ( ']' )
    // regexopt.g:93:14: ']'
    {
        MATCHC(']');
        if  (HASEXCEPTION())
        {
            goto ruleRBRACKETEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRBRACKETEx; /* Prevent compiler warnings */
    ruleRBRACKETEx: ;

}
// $ANTLR end RBRACKET

//   Comes from: 94:7: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LBRACE
 *
 * Looks to match the characters the constitute the token LBRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLBRACE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LBRACE;


    // regexopt.g:94:7: ( '{' )
    // regexopt.g:94:14: '{'
    {
        MATCHC('{');
        if  (HASEXCEPTION())
        {
            goto ruleLBRACEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLBRACEEx; /* Prevent compiler warnings */
    ruleLBRACEEx: ;

}
// $ANTLR end LBRACE

//   Comes from: 95:7: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RBRACE
 *
 * Looks to match the characters the constitute the token RBRACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRBRACE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RBRACE;


    // regexopt.g:95:7: ( '}' )
    // regexopt.g:95:14: '}'
    {
        MATCHC('}');
        if  (HASEXCEPTION())
        {
            goto ruleRBRACEEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRBRACEEx; /* Prevent compiler warnings */
    ruleRBRACEEx: ;

}
// $ANTLR end RBRACE

//   Comes from: 96:6: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BINOR
 *
 * Looks to match the characters the constitute the token BINOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBINOR(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BINOR;


    // regexopt.g:96:6: ( '|' )
    // regexopt.g:96:14: '|'
    {
        MATCHC('|');
        if  (HASEXCEPTION())
        {
            goto ruleBINOREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBINOREx; /* Prevent compiler warnings */
    ruleBINOREx: ;

}
// $ANTLR end BINOR

//   Comes from: 97:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STAR
 *
 * Looks to match the characters the constitute the token STAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTAR(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STAR;


    // regexopt.g:97:5: ( '*' )
    // regexopt.g:97:14: '*'
    {
        MATCHC('*');
        if  (HASEXCEPTION())
        {
            goto ruleSTAREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTAREx; /* Prevent compiler warnings */
    ruleSTAREx: ;

}
// $ANTLR end STAR

//   Comes from: 98:5: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PLUS;


    // regexopt.g:98:5: ( '+' )
    // regexopt.g:98:14: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto rulePLUSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 99:6: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUEST
 *
 * Looks to match the characters the constitute the token QUEST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUEST(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUEST;


    // regexopt.g:99:6: ( '?' )
    // regexopt.g:99:14: '?'
    {
        MATCHC('?');
        if  (HASEXCEPTION())
        {
            goto ruleQUESTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleQUESTEx; /* Prevent compiler warnings */
    ruleQUESTEx: ;

}
// $ANTLR end QUEST

//   Comes from: 100:4: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOT
 *
 * Looks to match the characters the constitute the token DOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOT(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOT;


    // regexopt.g:100:4: ( '.' )
    // regexopt.g:100:14: '.'
    {
        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleDOTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOTEx; /* Prevent compiler warnings */
    ruleDOTEx: ;

}
// $ANTLR end DOT

//   Comes from: 101:12: ( '{0' ( ',' )? '}' | '{0,' ( '0' .. '9' )+ '}' | '{,' ( '0' .. '9' )+ '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ZEROANDMORE
 *
 * Looks to match the characters the constitute the token ZEROANDMORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mZEROANDMORE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ZEROANDMORE;


    {
        //  regexopt.g:101:12: ( '{0' ( ',' )? '}' | '{0,' ( '0' .. '9' )+ '}' | '{,' ( '0' .. '9' )+ '}' )

        ANTLR3_UINT32 alt4;

        alt4=3;

        switch ( LA(1) )
        {
        case '{':
        	{
        		switch ( LA(2) )
        		{
        		case '0':
        			{
        				switch ( LA(3) )
        				{
        				case ',':
        					{
        						switch ( LA(4) )
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        						case '8':
        						case '9':
        							{
        								alt4=2;
        							}
        						    break;
        						case '}':
        							{
        								alt4=1;
        							}
        						    break;

        						default:
        						    CONSTRUCTEX();
        						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        						    EXCEPTION->message      = (void *)"";
        						    EXCEPTION->decisionNum  = 4;
        						    EXCEPTION->state        = 4;


        						    goto ruleZEROANDMOREEx;

        						}

        					}
        				    break;
        				case '}':
        					{
        						alt4=1;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 4;
        				    EXCEPTION->state        = 2;


        				    goto ruleZEROANDMOREEx;

        				}

        			}
        		    break;
        		case ',':
        			{
        				alt4=3;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 4;
        		    EXCEPTION->state        = 1;


        		    goto ruleZEROANDMOREEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleZEROANDMOREEx;

        }

        switch (alt4)
        {
    	case 1:
    	    // regexopt.g:101:14: '{0' ( ',' )? '}'
    	    {
    	        MATCHS(lit_13);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }




    	        // regexopt.g:101:19: ( ',' )?
    	        {
    	            int alt1=2;
    	            switch ( LA(1) )
    	            {
    	                case ',':
    	                	{
    	                		alt1=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt1)
    	            {
    	        	case 1:
    	        	    // regexopt.g:101:19: ','
    	        	    {
    	        	        MATCHC(',');
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleZEROANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // regexopt.g:101:30: '{0,' ( '0' .. '9' )+ '}'
    	    {
    	        MATCHS(lit_14);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }




    	        // regexopt.g:101:36: ( '0' .. '9' )+
    	        {
    	            int cnt2=0;

    	            for (;;)
    	            {
    	                int alt2=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt2=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt2)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleZEROANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt2 >= 1 )
    	        		{
    	        		    goto loop2;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleZEROANDMOREEx;
    	        	}
    	        	cnt2++;
    	            }
    	            loop2: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // regexopt.g:102:14: '{,' ( '0' .. '9' )+ '}'
    	    {
    	        MATCHS(lit_15);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }




    	        // regexopt.g:102:19: ( '0' .. '9' )+
    	        {
    	            int cnt3=0;

    	            for (;;)
    	            {
    	                int alt3=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt3=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt3)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleZEROANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt3 >= 1 )
    	        		{
    	        		    goto loop3;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleZEROANDMOREEx;
    	        	}
    	        	cnt3++;
    	            }
    	            loop3: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleZEROANDMOREEx;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleZEROANDMOREEx; /* Prevent compiler warnings */
    ruleZEROANDMOREEx: ;

}
// $ANTLR end ZEROANDMORE

//   Comes from: 103:11: ( '{1' ( ',' )? '}' | '{1,' ( '0' .. '9' )+ '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ONEANDMORE
 *
 * Looks to match the characters the constitute the token ONEANDMORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mONEANDMORE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ONEANDMORE;


    {
        //  regexopt.g:103:11: ( '{1' ( ',' )? '}' | '{1,' ( '0' .. '9' )+ '}' )

        ANTLR3_UINT32 alt7;

        alt7=2;

        switch ( LA(1) )
        {
        case '{':
        	{
        		switch ( LA(2) )
        		{
        		case '1':
        			{
        				switch ( LA(3) )
        				{
        				case ',':
        					{
        						switch ( LA(4) )
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        						case '8':
        						case '9':
        							{
        								alt7=2;
        							}
        						    break;
        						case '}':
        							{
        								alt7=1;
        							}
        						    break;

        						default:
        						    CONSTRUCTEX();
        						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        						    EXCEPTION->message      = (void *)"";
        						    EXCEPTION->decisionNum  = 7;
        						    EXCEPTION->state        = 3;


        						    goto ruleONEANDMOREEx;

        						}

        					}
        				    break;
        				case '}':
        					{
        						alt7=1;
        					}
        				    break;

        				default:
        				    CONSTRUCTEX();
        				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        				    EXCEPTION->message      = (void *)"";
        				    EXCEPTION->decisionNum  = 7;
        				    EXCEPTION->state        = 2;


        				    goto ruleONEANDMOREEx;

        				}

        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 7;
        		    EXCEPTION->state        = 1;


        		    goto ruleONEANDMOREEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 7;
            EXCEPTION->state        = 0;


            goto ruleONEANDMOREEx;

        }

        switch (alt7)
        {
    	case 1:
    	    // regexopt.g:103:14: '{1' ( ',' )? '}'
    	    {
    	        MATCHS(lit_16);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleONEANDMOREEx;
    	        }




    	        // regexopt.g:103:19: ( ',' )?
    	        {
    	            int alt5=2;
    	            switch ( LA(1) )
    	            {
    	                case ',':
    	                	{
    	                		alt5=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt5)
    	            {
    	        	case 1:
    	        	    // regexopt.g:103:19: ','
    	        	    {
    	        	        MATCHC(',');
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleONEANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleONEANDMOREEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // regexopt.g:103:30: '{1,' ( '0' .. '9' )+ '}'
    	    {
    	        MATCHS(lit_17);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleONEANDMOREEx;
    	        }




    	        // regexopt.g:103:36: ( '0' .. '9' )+
    	        {
    	            int cnt6=0;

    	            for (;;)
    	            {
    	                int alt6=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt6=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt6)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleONEANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt6 >= 1 )
    	        		{
    	        		    goto loop6;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleONEANDMOREEx;
    	        	}
    	        	cnt6++;
    	            }
    	            loop6: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleONEANDMOREEx;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleONEANDMOREEx; /* Prevent compiler warnings */
    ruleONEANDMOREEx: ;

}
// $ANTLR end ONEANDMORE

//   Comes from: 104:11: ( '{' ( '2' .. '9' ) ( '0' .. '9' )* ( ',' )? '}' | '{' ( '2' .. '9' ) ( '0' .. '9' )* ',' ( '0' .. '9' )+ '}' | '{1' ( '0' .. '9' )+ ( ',' )? '}' | '{1' ( '0' .. '9' )+ ',' ( '0' .. '9' )+ '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TWOANDMORE
 *
 * Looks to match the characters the constitute the token TWOANDMORE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTWOANDMORE(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TWOANDMORE;


    {
        //  regexopt.g:104:11: ( '{' ( '2' .. '9' ) ( '0' .. '9' )* ( ',' )? '}' | '{' ( '2' .. '9' ) ( '0' .. '9' )* ',' ( '0' .. '9' )+ '}' | '{1' ( '0' .. '9' )+ ( ',' )? '}' | '{1' ( '0' .. '9' )+ ',' ( '0' .. '9' )+ '}' )

        ANTLR3_UINT32 alt16;

        alt16=4;

        alt16 = cdfa16.predict(ctx, RECOGNIZER, ISTREAM, &cdfa16);
        if  (HASEXCEPTION())
        {
            goto ruleTWOANDMOREEx;
        }

        switch (alt16)
        {
    	case 1:
    	    // regexopt.g:104:14: '{' ( '2' .. '9' ) ( '0' .. '9' )* ( ',' )? '}'
    	    {
    	        MATCHC('{');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	        if ( ((LA(1) >= '2') && (LA(1) <= '9')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleTWOANDMOREEx;
    	        }


    	        // regexopt.g:104:28: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt8=2;
    	            switch ( LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt8=1;
    	            	}
    	                break;

    	            }

    	            switch (alt8)
    	            {
    	        	case 1:
    	        	    // regexopt.g:
    	        	    {
    	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	        {
    	        	            CONSUME();
    	        	        }
    	        	        else
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleTWOANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop8;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop8: ; /* Jump out to here if this rule does not match */


    	        // regexopt.g:104:40: ( ',' )?
    	        {
    	            int alt9=2;
    	            switch ( LA(1) )
    	            {
    	                case ',':
    	                	{
    	                		alt9=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt9)
    	            {
    	        	case 1:
    	        	    // regexopt.g:104:40: ','
    	        	    {
    	        	        MATCHC(',');
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleTWOANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // regexopt.g:104:51: '{' ( '2' .. '9' ) ( '0' .. '9' )* ',' ( '0' .. '9' )+ '}'
    	    {
    	        MATCHC('{');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	        if ( ((LA(1) >= '2') && (LA(1) <= '9')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleTWOANDMOREEx;
    	        }


    	        // regexopt.g:104:65: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt10=2;
    	            switch ( LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt10=1;
    	            	}
    	                break;

    	            }

    	            switch (alt10)
    	            {
    	        	case 1:
    	        	    // regexopt.g:
    	        	    {
    	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	        {
    	        	            CONSUME();
    	        	        }
    	        	        else
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleTWOANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop10;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop10: ; /* Jump out to here if this rule does not match */


    	        MATCHC(',');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	        // regexopt.g:104:80: ( '0' .. '9' )+
    	        {
    	            int cnt11=0;

    	            for (;;)
    	            {
    	                int alt11=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt11=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt11)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleTWOANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt11 >= 1 )
    	        		{
    	        		    goto loop11;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleTWOANDMOREEx;
    	        	}
    	        	cnt11++;
    	            }
    	            loop11: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // regexopt.g:105:14: '{1' ( '0' .. '9' )+ ( ',' )? '}'
    	    {
    	        MATCHS(lit_16);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }




    	        // regexopt.g:105:19: ( '0' .. '9' )+
    	        {
    	            int cnt12=0;

    	            for (;;)
    	            {
    	                int alt12=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt12=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt12)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleTWOANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt12 >= 1 )
    	        		{
    	        		    goto loop12;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleTWOANDMOREEx;
    	        	}
    	        	cnt12++;
    	            }
    	            loop12: ;	/* Jump to here if this rule does not match */
    	        }

    	        // regexopt.g:105:31: ( ',' )?
    	        {
    	            int alt13=2;
    	            switch ( LA(1) )
    	            {
    	                case ',':
    	                	{
    	                		alt13=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt13)
    	            {
    	        	case 1:
    	        	    // regexopt.g:105:31: ','
    	        	    {
    	        	        MATCHC(',');
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleTWOANDMOREEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // regexopt.g:105:42: '{1' ( '0' .. '9' )+ ',' ( '0' .. '9' )+ '}'
    	    {
    	        MATCHS(lit_16);
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }




    	        // regexopt.g:105:47: ( '0' .. '9' )+
    	        {
    	            int cnt14=0;

    	            for (;;)
    	            {
    	                int alt14=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt14=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt14)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleTWOANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt14 >= 1 )
    	        		{
    	        		    goto loop14;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleTWOANDMOREEx;
    	        	}
    	        	cnt14++;
    	            }
    	            loop14: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC(',');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	        // regexopt.g:105:63: ( '0' .. '9' )+
    	        {
    	            int cnt15=0;

    	            for (;;)
    	            {
    	                int alt15=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt15=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt15)
    	        	{
    	        	    case 1:
    	        	        // regexopt.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleTWOANDMOREEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt15 >= 1 )
    	        		{
    	        		    goto loop15;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleTWOANDMOREEx;
    	        	}
    	        	cnt15++;
    	            }
    	            loop15: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('}');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTWOANDMOREEx;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTWOANDMOREEx; /* Prevent compiler warnings */
    ruleTWOANDMOREEx: ;

}
// $ANTLR end TWOANDMORE

//   Comes from: 106:4: ( '\\\\' ( STAR | PLUS | QUEST | LBRACE | RBRACE | LBRACKET | RBRACKET | LPAREN | RPAREN | DOT | BINOR | '\\\\' | '^' | '$' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC
 *
 * Looks to match the characters the constitute the token ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESC(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ESC;


    // regexopt.g:106:4: ( '\\\\' ( STAR | PLUS | QUEST | LBRACE | RBRACE | LBRACKET | RBRACKET | LPAREN | RPAREN | DOT | BINOR | '\\\\' | '^' | '$' ) )
    // regexopt.g:106:14: '\\\\' ( STAR | PLUS | QUEST | LBRACE | RBRACE | LBRACKET | RBRACKET | LPAREN | RPAREN | DOT | BINOR | '\\\\' | '^' | '$' )
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleESCEx;
        }


        if ( LA(1) == '$' || ((LA(1) >= '(') && (LA(1) <= '+')) || LA(1) == '.' || LA(1) == '?' || ((LA(1) >= '[') && (LA(1) <= '^')) || ((LA(1) >= '{') && (LA(1) <= '}')) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleESCEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleESCEx; /* Prevent compiler warnings */
    ruleESCEx: ;

}
// $ANTLR end ESC

//   Comes from: 109:8: ( '\\\\' ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BACKREF
 *
 * Looks to match the characters the constitute the token BACKREF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBACKREF(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BACKREF;


    // regexopt.g:109:8: ( '\\\\' ( '0' .. '9' )+ )
    // regexopt.g:109:14: '\\\\' ( '0' .. '9' )+
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleBACKREFEx;
        }


        // regexopt.g:109:19: ( '0' .. '9' )+
        {
            int cnt17=0;

            for (;;)
            {
                int alt17=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt17=1;
        		}
        	    break;

        	}

        	switch (alt17)
        	{
        	    case 1:
        	        // regexopt.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleBACKREFEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt17 >= 1 )
        		{
        		    goto loop17;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleBACKREFEx;
        	}
        	cnt17++;
            }
            loop17: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBACKREFEx; /* Prevent compiler warnings */
    ruleBACKREFEx: ;

}
// $ANTLR end BACKREF

//   Comes from: 110:8: ( '\\\\' . )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SPECIAL
 *
 * Looks to match the characters the constitute the token SPECIAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSPECIAL(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SPECIAL;


    // regexopt.g:110:8: ( '\\\\' . )
    // regexopt.g:110:14: '\\\\' .
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleSPECIALEx;
        }


        MATCHANY();
        if  (HASEXCEPTION())
        {
            goto ruleSPECIALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSPECIALEx; /* Prevent compiler warnings */
    ruleSPECIALEx: ;

}
// $ANTLR end SPECIAL

//   Comes from: 111:7: (~ ( STAR | PLUS | QUEST | LBRACE | RBRACE | LBRACKET | RBRACKET | LPAREN | RPAREN | DOT | BINOR | '\\uFFFF' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOMETA
 *
 * Looks to match the characters the constitute the token NOMETA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOMETA(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOMETA;


    // regexopt.g:111:7: (~ ( STAR | PLUS | QUEST | LBRACE | RBRACE | LBRACKET | RBRACKET | LPAREN | RPAREN | DOT | BINOR | '\\uFFFF' ) )
    // regexopt.g:
    {
        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\'')) || ((LA(1) >= ',') && (LA(1) <= '-')) || ((LA(1) >= '/') && (LA(1) <= '>')) || ((LA(1) >= '@') && (LA(1) <= 'Z')) || LA(1) == '\\' || ((LA(1) >= '^') && (LA(1) <= 'z')) || ((LA(1) >= '~') && (LA(1) <= 0xFFFE)) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleNOMETAEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOMETAEx; /* Prevent compiler warnings */
    ruleNOMETAEx: ;

}
// $ANTLR end NOMETA

//   Comes from: 114:5: ( LBRACKET ( CHARCLASS )+ RBRACKET )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ENUM
 *
 * Looks to match the characters the constitute the token ENUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mENUM(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ENUM;


    // regexopt.g:114:5: ( LBRACKET ( CHARCLASS )+ RBRACKET )
    // regexopt.g:114:7: LBRACKET ( CHARCLASS )+ RBRACKET
    {
        /* 114:7: LBRACKET ( CHARCLASS )+ RBRACKET */
        mLBRACKET(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleENUMEx;
        }



        // regexopt.g:114:16: ( CHARCLASS )+
        {
            int cnt18=0;

            for (;;)
            {
                int alt18=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA18_0 = LA(1);
        	    if ( (((LA18_0 >= 0x0000) && (LA18_0 <= '\'')) || ((LA18_0 >= ',') && (LA18_0 <= '>')) || ((LA18_0 >= '@') && (LA18_0 <= '\\')) || ((LA18_0 >= '^') && (LA18_0 <= 'z')) || ((LA18_0 >= '~') && (LA18_0 <= 0xFFFE))))
        	    {
        	        alt18=1;
        	    }

        	}
        	switch (alt18)
        	{
        	    case 1:
        	        // regexopt.g:114:16: CHARCLASS
        	        {
        	            /* 114:16: CHARCLASS */
        	            mCHARCLASS(ctx );
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleENUMEx;
        	            }



        	        }
        	        break;

        	    default:

        		if ( cnt18 >= 1 )
        		{
        		    goto loop18;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleENUMEx;
        	}
        	cnt18++;
            }
            loop18: ;	/* Jump to here if this rule does not match */
        }

        /* 114:7: LBRACKET ( CHARCLASS )+ RBRACKET */
        mRBRACKET(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleENUMEx;
        }



    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleENUMEx; /* Prevent compiler warnings */
    ruleENUMEx: ;

}
// $ANTLR end ENUM

//   Comes from: 115:19: ( ( ( NOMETA | DOT ) '-' ( NOMETA | DOT ) | ALNUM | ALPHA | BLANK | CNTRL | DIGIT | GRAPH | LOWER | PRINT | PUNCT | SPACE | UPPER | XDIGIT | ( NOMETA | DOT ) ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHARCLASS
 *
 * Looks to match the characters the constitute the token CHARCLASS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHARCLASS(pregexoptLexer ctx)
{
	ANTLR3_UINT32	_type;


    // regexopt.g:115:19: ( ( ( NOMETA | DOT ) '-' ( NOMETA | DOT ) | ALNUM | ALPHA | BLANK | CNTRL | DIGIT | GRAPH | LOWER | PRINT | PUNCT | SPACE | UPPER | XDIGIT | ( NOMETA | DOT ) ) )
    // regexopt.g:115:21: ( ( NOMETA | DOT ) '-' ( NOMETA | DOT ) | ALNUM | ALPHA | BLANK | CNTRL | DIGIT | GRAPH | LOWER | PRINT | PUNCT | SPACE | UPPER | XDIGIT | ( NOMETA | DOT ) )
    {
        // regexopt.g:115:21: ( ( NOMETA | DOT ) '-' ( NOMETA | DOT ) | ALNUM | ALPHA | BLANK | CNTRL | DIGIT | GRAPH | LOWER | PRINT | PUNCT | SPACE | UPPER | XDIGIT | ( NOMETA | DOT ) )
        {
            int alt19=14;
            {
                int LA19_0 = LA(1);
                if ( (((LA19_0 >= 0x0000) && (LA19_0 <= '\'')) || ((LA19_0 >= ',') && (LA19_0 <= '>')) || ((LA19_0 >= '@') && (LA19_0 <= 'Z')) || LA19_0 == '\\' || ((LA19_0 >= '^') && (LA19_0 <= 'z')) || ((LA19_0 >= '~') && (LA19_0 <= 0xFFFE))))
                {
                    switch ( LA(2) )
                    {
                    case '-':
                    	{
                    		alt19=1;
                    	}
                        break;

                    default:
                        alt19=14;
                    }

                }
                else if ( (LA19_0 == '['))
                {
                    switch ( LA(2) )
                    {
                    case ':':
                    	{
                    		switch ( LA(3) )
                    		{
                    		case 'a':
                    			{
                    				switch ( LA(4) )
                    				{
                    				case 'l':
                    					{
                    						switch ( LA(5) )
                    						{
                    						case 'n':
                    							{
                    								alt19=2;
                    							}
                    						    break;
                    						case 'p':
                    							{
                    								alt19=3;
                    							}
                    						    break;

                    						default:
                    						    CONSTRUCTEX();
                    						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    						    EXCEPTION->message      = (void *)"";
                    						    EXCEPTION->decisionNum  = 19;
                    						    EXCEPTION->state        = 16;


                    						    goto ruleCHARCLASSEx;

                    						}

                    					}
                    				    break;

                    				default:
                    				    CONSTRUCTEX();
                    				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    				    EXCEPTION->message      = (void *)"";
                    				    EXCEPTION->decisionNum  = 19;
                    				    EXCEPTION->state        = 6;


                    				    goto ruleCHARCLASSEx;

                    				}

                    			}
                    		    break;
                    		case 'b':
                    			{
                    				alt19=4;
                    			}
                    		    break;
                    		case 'c':
                    			{
                    				alt19=5;
                    			}
                    		    break;
                    		case 'd':
                    			{
                    				alt19=6;
                    			}
                    		    break;
                    		case 'g':
                    			{
                    				alt19=7;
                    			}
                    		    break;
                    		case 'l':
                    			{
                    				alt19=8;
                    			}
                    		    break;
                    		case 'p':
                    			{
                    				switch ( LA(4) )
                    				{
                    				case 'r':
                    					{
                    						alt19=9;
                    					}
                    				    break;
                    				case 'u':
                    					{
                    						alt19=10;
                    					}
                    				    break;

                    				default:
                    				    CONSTRUCTEX();
                    				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    				    EXCEPTION->message      = (void *)"";
                    				    EXCEPTION->decisionNum  = 19;
                    				    EXCEPTION->state        = 12;


                    				    goto ruleCHARCLASSEx;

                    				}

                    			}
                    		    break;
                    		case 's':
                    			{
                    				alt19=11;
                    			}
                    		    break;
                    		case 'u':
                    			{
                    				alt19=12;
                    			}
                    		    break;
                    		case 'x':
                    			{
                    				alt19=13;
                    			}
                    		    break;

                    		default:
                    		    CONSTRUCTEX();
                    		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		    EXCEPTION->message      = (void *)"";
                    		    EXCEPTION->decisionNum  = 19;
                    		    EXCEPTION->state        = 5;


                    		    goto ruleCHARCLASSEx;

                    		}

                    	}
                        break;

                    default:
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 19;
                        EXCEPTION->state        = 2;


                        goto ruleCHARCLASSEx;

                    }

                }
                else
                {

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 19;
                    EXCEPTION->state        = 0;


                    goto ruleCHARCLASSEx;

                }
            }
            switch (alt19)
            {
        	case 1:
        	    // regexopt.g:115:23: ( NOMETA | DOT ) '-' ( NOMETA | DOT )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\'')) || ((LA(1) >= ',') && (LA(1) <= '>')) || ((LA(1) >= '@') && (LA(1) <= 'Z')) || LA(1) == '\\' || ((LA(1) >= '^') && (LA(1) <= 'z')) || ((LA(1) >= '~') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleCHARCLASSEx;
        	        }


        	        MATCHC('-');
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }


        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\'')) || ((LA(1) >= ',') && (LA(1) <= '>')) || ((LA(1) >= '@') && (LA(1) <= 'Z')) || LA(1) == '\\' || ((LA(1) >= '^') && (LA(1) <= 'z')) || ((LA(1) >= '~') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleCHARCLASSEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // regexopt.g:116:14: ALNUM
        	    {
        	        /* 116:14: ALNUM */
        	        mALNUM(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // regexopt.g:116:22: ALPHA
        	    {
        	        /* 116:22: ALPHA */
        	        mALPHA(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // regexopt.g:116:30: BLANK
        	    {
        	        /* 116:30: BLANK */
        	        mBLANK(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // regexopt.g:116:38: CNTRL
        	    {
        	        /* 116:38: CNTRL */
        	        mCNTRL(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 6:
        	    // regexopt.g:116:46: DIGIT
        	    {
        	        /* 116:46: DIGIT */
        	        mDIGIT(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 7:
        	    // regexopt.g:116:54: GRAPH
        	    {
        	        /* 116:54: GRAPH */
        	        mGRAPH(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 8:
        	    // regexopt.g:116:62: LOWER
        	    {
        	        /* 116:62: LOWER */
        	        mLOWER(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 9:
        	    // regexopt.g:117:14: PRINT
        	    {
        	        /* 117:14: PRINT */
        	        mPRINT(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 10:
        	    // regexopt.g:117:22: PUNCT
        	    {
        	        /* 117:22: PUNCT */
        	        mPUNCT(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 11:
        	    // regexopt.g:117:30: SPACE
        	    {
        	        /* 117:30: SPACE */
        	        mSPACE(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 12:
        	    // regexopt.g:117:38: UPPER
        	    {
        	        /* 117:38: UPPER */
        	        mUPPER(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 13:
        	    // regexopt.g:117:46: XDIGIT
        	    {
        	        /* 117:46: XDIGIT */
        	        mXDIGIT(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHARCLASSEx;
        	        }



        	    }
        	    break;
        	case 14:
        	    // regexopt.g:118:14: ( NOMETA | DOT )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\'')) || ((LA(1) >= ',') && (LA(1) <= '>')) || ((LA(1) >= '@') && (LA(1) <= 'Z')) || LA(1) == '\\' || ((LA(1) >= '^') && (LA(1) <= 'z')) || ((LA(1) >= '~') && (LA(1) <= 0xFFFE)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleCHARCLASSEx;
        	        }


        	    }
        	    break;

            }
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleCHARCLASSEx; /* Prevent compiler warnings */
    ruleCHARCLASSEx: ;

}
// $ANTLR end CHARCLASS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pregexoptLexer ctx)
{
    {
        //  regexopt.g:1:8: ( ALNUM | ALPHA | BLANK | CNTRL | DIGIT | GRAPH | LOWER | PRINT | PUNCT | SPACE | UPPER | XDIGIT | WS_ | LPAREN | RPAREN | LBRACKET | RBRACKET | LBRACE | RBRACE | BINOR | STAR | PLUS | QUEST | DOT | ZEROANDMORE | ONEANDMORE | TWOANDMORE | ESC | BACKREF | SPECIAL | NOMETA | ENUM )

        ANTLR3_UINT32 alt20;

        alt20=32;

        {
            int LA20_0 = LA(1);
            if ( (LA20_0 == '['))
            {
                {
                    int LA20_1 = LA(2);
                    if ( (LA20_1 == ':'))
                    {
                        {
                            int LA20_15 = LA(3);
                            if ( (LA20_15 == 'a'))
                            {
                                {
                                    int LA20_26 = LA(4);
                                    if ( (LA20_26 == 'l'))
                                    {
                                        {
                                            int LA20_39 = LA(5);
                                            if ( (LA20_39 == 'n'))
                                            {
                                                {
                                                    int LA20_50 = LA(6);
                                                    if ( (LA20_50 == 'u'))
                                                    {
                                                        {
                                                            int LA20_62 = LA(7);
                                                            if ( (LA20_62 == 'm'))
                                                            {
                                                                {
                                                                    int LA20_74 = LA(8);
                                                                    if ( (LA20_74 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_86 = LA(9);
                                                                            if ( (LA20_86 == ']'))
                                                                            {
                                                                                alt20=1;
                                                                            }
                                                                            else if ( (((LA20_86 >= 0x0000) && (LA20_86 <= '\'')) || ((LA20_86 >= ',') && (LA20_86 <= '>')) || ((LA20_86 >= '@') && (LA20_86 <= '\\')) || ((LA20_86 >= '^') && (LA20_86 <= 'z')) || ((LA20_86 >= '~') && (LA20_86 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 86;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_74 >= 0x0000) && (LA20_74 <= '\'')) || ((LA20_74 >= ',') && (LA20_74 <= '9')) || ((LA20_74 >= ';') && (LA20_74 <= '>')) || ((LA20_74 >= '@') && (LA20_74 <= 'z')) || ((LA20_74 >= '~') && (LA20_74 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 74;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_62 >= 0x0000) && (LA20_62 <= '\'')) || ((LA20_62 >= ',') && (LA20_62 <= '>')) || ((LA20_62 >= '@') && (LA20_62 <= 'l')) || ((LA20_62 >= 'n') && (LA20_62 <= 'z')) || ((LA20_62 >= '~') && (LA20_62 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 62;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_50 >= 0x0000) && (LA20_50 <= '\'')) || ((LA20_50 >= ',') && (LA20_50 <= '>')) || ((LA20_50 >= '@') && (LA20_50 <= 't')) || ((LA20_50 >= 'v') && (LA20_50 <= 'z')) || ((LA20_50 >= '~') && (LA20_50 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 50;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (LA20_39 == 'p'))
                                            {
                                                {
                                                    int LA20_51 = LA(6);
                                                    if ( (LA20_51 == 'h'))
                                                    {
                                                        {
                                                            int LA20_63 = LA(7);
                                                            if ( (LA20_63 == 'a'))
                                                            {
                                                                {
                                                                    int LA20_75 = LA(8);
                                                                    if ( (LA20_75 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_87 = LA(9);
                                                                            if ( (LA20_87 == ']'))
                                                                            {
                                                                                alt20=2;
                                                                            }
                                                                            else if ( (((LA20_87 >= 0x0000) && (LA20_87 <= '\'')) || ((LA20_87 >= ',') && (LA20_87 <= '>')) || ((LA20_87 >= '@') && (LA20_87 <= '\\')) || ((LA20_87 >= '^') && (LA20_87 <= 'z')) || ((LA20_87 >= '~') && (LA20_87 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 87;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_75 >= 0x0000) && (LA20_75 <= '\'')) || ((LA20_75 >= ',') && (LA20_75 <= '9')) || ((LA20_75 >= ';') && (LA20_75 <= '>')) || ((LA20_75 >= '@') && (LA20_75 <= 'z')) || ((LA20_75 >= '~') && (LA20_75 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 75;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_63 >= 0x0000) && (LA20_63 <= '\'')) || ((LA20_63 >= ',') && (LA20_63 <= '>')) || ((LA20_63 >= '@') && (LA20_63 <= '`')) || ((LA20_63 >= 'b') && (LA20_63 <= 'z')) || ((LA20_63 >= '~') && (LA20_63 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 63;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_51 >= 0x0000) && (LA20_51 <= '\'')) || ((LA20_51 >= ',') && (LA20_51 <= '>')) || ((LA20_51 >= '@') && (LA20_51 <= 'g')) || ((LA20_51 >= 'i') && (LA20_51 <= 'z')) || ((LA20_51 >= '~') && (LA20_51 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 51;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_39 >= 0x0000) && (LA20_39 <= '\'')) || ((LA20_39 >= ',') && (LA20_39 <= '>')) || ((LA20_39 >= '@') && (LA20_39 <= 'm')) || LA20_39 == 'o' || ((LA20_39 >= 'q') && (LA20_39 <= 'z')) || ((LA20_39 >= '~') && (LA20_39 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 39;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_26 >= 0x0000) && (LA20_26 <= '\'')) || ((LA20_26 >= ',') && (LA20_26 <= '>')) || ((LA20_26 >= '@') && (LA20_26 <= 'k')) || ((LA20_26 >= 'm') && (LA20_26 <= 'z')) || ((LA20_26 >= '~') && (LA20_26 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 26;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'b'))
                            {
                                {
                                    int LA20_27 = LA(4);
                                    if ( (LA20_27 == 'l'))
                                    {
                                        {
                                            int LA20_40 = LA(5);
                                            if ( (LA20_40 == 'a'))
                                            {
                                                {
                                                    int LA20_52 = LA(6);
                                                    if ( (LA20_52 == 'n'))
                                                    {
                                                        {
                                                            int LA20_64 = LA(7);
                                                            if ( (LA20_64 == 'k'))
                                                            {
                                                                {
                                                                    int LA20_76 = LA(8);
                                                                    if ( (LA20_76 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_88 = LA(9);
                                                                            if ( (LA20_88 == ']'))
                                                                            {
                                                                                alt20=3;
                                                                            }
                                                                            else if ( (((LA20_88 >= 0x0000) && (LA20_88 <= '\'')) || ((LA20_88 >= ',') && (LA20_88 <= '>')) || ((LA20_88 >= '@') && (LA20_88 <= '\\')) || ((LA20_88 >= '^') && (LA20_88 <= 'z')) || ((LA20_88 >= '~') && (LA20_88 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 88;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_76 >= 0x0000) && (LA20_76 <= '\'')) || ((LA20_76 >= ',') && (LA20_76 <= '9')) || ((LA20_76 >= ';') && (LA20_76 <= '>')) || ((LA20_76 >= '@') && (LA20_76 <= 'z')) || ((LA20_76 >= '~') && (LA20_76 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 76;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_64 >= 0x0000) && (LA20_64 <= '\'')) || ((LA20_64 >= ',') && (LA20_64 <= '>')) || ((LA20_64 >= '@') && (LA20_64 <= 'j')) || ((LA20_64 >= 'l') && (LA20_64 <= 'z')) || ((LA20_64 >= '~') && (LA20_64 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 64;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_52 >= 0x0000) && (LA20_52 <= '\'')) || ((LA20_52 >= ',') && (LA20_52 <= '>')) || ((LA20_52 >= '@') && (LA20_52 <= 'm')) || ((LA20_52 >= 'o') && (LA20_52 <= 'z')) || ((LA20_52 >= '~') && (LA20_52 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 52;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_40 >= 0x0000) && (LA20_40 <= '\'')) || ((LA20_40 >= ',') && (LA20_40 <= '>')) || ((LA20_40 >= '@') && (LA20_40 <= '`')) || ((LA20_40 >= 'b') && (LA20_40 <= 'z')) || ((LA20_40 >= '~') && (LA20_40 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 40;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_27 >= 0x0000) && (LA20_27 <= '\'')) || ((LA20_27 >= ',') && (LA20_27 <= '>')) || ((LA20_27 >= '@') && (LA20_27 <= 'k')) || ((LA20_27 >= 'm') && (LA20_27 <= 'z')) || ((LA20_27 >= '~') && (LA20_27 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 27;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'c'))
                            {
                                {
                                    int LA20_28 = LA(4);
                                    if ( (LA20_28 == 'n'))
                                    {
                                        {
                                            int LA20_41 = LA(5);
                                            if ( (LA20_41 == 't'))
                                            {
                                                {
                                                    int LA20_53 = LA(6);
                                                    if ( (LA20_53 == 'r'))
                                                    {
                                                        {
                                                            int LA20_65 = LA(7);
                                                            if ( (LA20_65 == 'l'))
                                                            {
                                                                {
                                                                    int LA20_77 = LA(8);
                                                                    if ( (LA20_77 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_89 = LA(9);
                                                                            if ( (LA20_89 == ']'))
                                                                            {
                                                                                alt20=4;
                                                                            }
                                                                            else if ( (((LA20_89 >= 0x0000) && (LA20_89 <= '\'')) || ((LA20_89 >= ',') && (LA20_89 <= '>')) || ((LA20_89 >= '@') && (LA20_89 <= '\\')) || ((LA20_89 >= '^') && (LA20_89 <= 'z')) || ((LA20_89 >= '~') && (LA20_89 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 89;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_77 >= 0x0000) && (LA20_77 <= '\'')) || ((LA20_77 >= ',') && (LA20_77 <= '9')) || ((LA20_77 >= ';') && (LA20_77 <= '>')) || ((LA20_77 >= '@') && (LA20_77 <= 'z')) || ((LA20_77 >= '~') && (LA20_77 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 77;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_65 >= 0x0000) && (LA20_65 <= '\'')) || ((LA20_65 >= ',') && (LA20_65 <= '>')) || ((LA20_65 >= '@') && (LA20_65 <= 'k')) || ((LA20_65 >= 'm') && (LA20_65 <= 'z')) || ((LA20_65 >= '~') && (LA20_65 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 65;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_53 >= 0x0000) && (LA20_53 <= '\'')) || ((LA20_53 >= ',') && (LA20_53 <= '>')) || ((LA20_53 >= '@') && (LA20_53 <= 'q')) || ((LA20_53 >= 's') && (LA20_53 <= 'z')) || ((LA20_53 >= '~') && (LA20_53 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 53;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_41 >= 0x0000) && (LA20_41 <= '\'')) || ((LA20_41 >= ',') && (LA20_41 <= '>')) || ((LA20_41 >= '@') && (LA20_41 <= 's')) || ((LA20_41 >= 'u') && (LA20_41 <= 'z')) || ((LA20_41 >= '~') && (LA20_41 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 41;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_28 >= 0x0000) && (LA20_28 <= '\'')) || ((LA20_28 >= ',') && (LA20_28 <= '>')) || ((LA20_28 >= '@') && (LA20_28 <= 'm')) || ((LA20_28 >= 'o') && (LA20_28 <= 'z')) || ((LA20_28 >= '~') && (LA20_28 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 28;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'd'))
                            {
                                {
                                    int LA20_29 = LA(4);
                                    if ( (LA20_29 == 'i'))
                                    {
                                        {
                                            int LA20_42 = LA(5);
                                            if ( (LA20_42 == 'g'))
                                            {
                                                {
                                                    int LA20_54 = LA(6);
                                                    if ( (LA20_54 == 'i'))
                                                    {
                                                        {
                                                            int LA20_66 = LA(7);
                                                            if ( (LA20_66 == 't'))
                                                            {
                                                                {
                                                                    int LA20_78 = LA(8);
                                                                    if ( (LA20_78 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_90 = LA(9);
                                                                            if ( (LA20_90 == ']'))
                                                                            {
                                                                                alt20=5;
                                                                            }
                                                                            else if ( (((LA20_90 >= 0x0000) && (LA20_90 <= '\'')) || ((LA20_90 >= ',') && (LA20_90 <= '>')) || ((LA20_90 >= '@') && (LA20_90 <= '\\')) || ((LA20_90 >= '^') && (LA20_90 <= 'z')) || ((LA20_90 >= '~') && (LA20_90 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 90;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_78 >= 0x0000) && (LA20_78 <= '\'')) || ((LA20_78 >= ',') && (LA20_78 <= '9')) || ((LA20_78 >= ';') && (LA20_78 <= '>')) || ((LA20_78 >= '@') && (LA20_78 <= 'z')) || ((LA20_78 >= '~') && (LA20_78 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 78;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_66 >= 0x0000) && (LA20_66 <= '\'')) || ((LA20_66 >= ',') && (LA20_66 <= '>')) || ((LA20_66 >= '@') && (LA20_66 <= 's')) || ((LA20_66 >= 'u') && (LA20_66 <= 'z')) || ((LA20_66 >= '~') && (LA20_66 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 66;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_54 >= 0x0000) && (LA20_54 <= '\'')) || ((LA20_54 >= ',') && (LA20_54 <= '>')) || ((LA20_54 >= '@') && (LA20_54 <= 'h')) || ((LA20_54 >= 'j') && (LA20_54 <= 'z')) || ((LA20_54 >= '~') && (LA20_54 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 54;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_42 >= 0x0000) && (LA20_42 <= '\'')) || ((LA20_42 >= ',') && (LA20_42 <= '>')) || ((LA20_42 >= '@') && (LA20_42 <= 'f')) || ((LA20_42 >= 'h') && (LA20_42 <= 'z')) || ((LA20_42 >= '~') && (LA20_42 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 42;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_29 >= 0x0000) && (LA20_29 <= '\'')) || ((LA20_29 >= ',') && (LA20_29 <= '>')) || ((LA20_29 >= '@') && (LA20_29 <= 'h')) || ((LA20_29 >= 'j') && (LA20_29 <= 'z')) || ((LA20_29 >= '~') && (LA20_29 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 29;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'g'))
                            {
                                {
                                    int LA20_30 = LA(4);
                                    if ( (LA20_30 == 'r'))
                                    {
                                        {
                                            int LA20_43 = LA(5);
                                            if ( (LA20_43 == 'a'))
                                            {
                                                {
                                                    int LA20_55 = LA(6);
                                                    if ( (LA20_55 == 'p'))
                                                    {
                                                        {
                                                            int LA20_67 = LA(7);
                                                            if ( (LA20_67 == 'h'))
                                                            {
                                                                {
                                                                    int LA20_79 = LA(8);
                                                                    if ( (LA20_79 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_91 = LA(9);
                                                                            if ( (LA20_91 == ']'))
                                                                            {
                                                                                alt20=6;
                                                                            }
                                                                            else if ( (((LA20_91 >= 0x0000) && (LA20_91 <= '\'')) || ((LA20_91 >= ',') && (LA20_91 <= '>')) || ((LA20_91 >= '@') && (LA20_91 <= '\\')) || ((LA20_91 >= '^') && (LA20_91 <= 'z')) || ((LA20_91 >= '~') && (LA20_91 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 91;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_79 >= 0x0000) && (LA20_79 <= '\'')) || ((LA20_79 >= ',') && (LA20_79 <= '9')) || ((LA20_79 >= ';') && (LA20_79 <= '>')) || ((LA20_79 >= '@') && (LA20_79 <= 'z')) || ((LA20_79 >= '~') && (LA20_79 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 79;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_67 >= 0x0000) && (LA20_67 <= '\'')) || ((LA20_67 >= ',') && (LA20_67 <= '>')) || ((LA20_67 >= '@') && (LA20_67 <= 'g')) || ((LA20_67 >= 'i') && (LA20_67 <= 'z')) || ((LA20_67 >= '~') && (LA20_67 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 67;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_55 >= 0x0000) && (LA20_55 <= '\'')) || ((LA20_55 >= ',') && (LA20_55 <= '>')) || ((LA20_55 >= '@') && (LA20_55 <= 'o')) || ((LA20_55 >= 'q') && (LA20_55 <= 'z')) || ((LA20_55 >= '~') && (LA20_55 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 55;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_43 >= 0x0000) && (LA20_43 <= '\'')) || ((LA20_43 >= ',') && (LA20_43 <= '>')) || ((LA20_43 >= '@') && (LA20_43 <= '`')) || ((LA20_43 >= 'b') && (LA20_43 <= 'z')) || ((LA20_43 >= '~') && (LA20_43 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 43;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_30 >= 0x0000) && (LA20_30 <= '\'')) || ((LA20_30 >= ',') && (LA20_30 <= '>')) || ((LA20_30 >= '@') && (LA20_30 <= 'q')) || ((LA20_30 >= 's') && (LA20_30 <= 'z')) || ((LA20_30 >= '~') && (LA20_30 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 30;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'l'))
                            {
                                {
                                    int LA20_31 = LA(4);
                                    if ( (LA20_31 == 'o'))
                                    {
                                        {
                                            int LA20_44 = LA(5);
                                            if ( (LA20_44 == 'w'))
                                            {
                                                {
                                                    int LA20_56 = LA(6);
                                                    if ( (LA20_56 == 'e'))
                                                    {
                                                        {
                                                            int LA20_68 = LA(7);
                                                            if ( (LA20_68 == 'r'))
                                                            {
                                                                {
                                                                    int LA20_80 = LA(8);
                                                                    if ( (LA20_80 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_92 = LA(9);
                                                                            if ( (LA20_92 == ']'))
                                                                            {
                                                                                alt20=7;
                                                                            }
                                                                            else if ( (((LA20_92 >= 0x0000) && (LA20_92 <= '\'')) || ((LA20_92 >= ',') && (LA20_92 <= '>')) || ((LA20_92 >= '@') && (LA20_92 <= '\\')) || ((LA20_92 >= '^') && (LA20_92 <= 'z')) || ((LA20_92 >= '~') && (LA20_92 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 92;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_80 >= 0x0000) && (LA20_80 <= '\'')) || ((LA20_80 >= ',') && (LA20_80 <= '9')) || ((LA20_80 >= ';') && (LA20_80 <= '>')) || ((LA20_80 >= '@') && (LA20_80 <= 'z')) || ((LA20_80 >= '~') && (LA20_80 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 80;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_68 >= 0x0000) && (LA20_68 <= '\'')) || ((LA20_68 >= ',') && (LA20_68 <= '>')) || ((LA20_68 >= '@') && (LA20_68 <= 'q')) || ((LA20_68 >= 's') && (LA20_68 <= 'z')) || ((LA20_68 >= '~') && (LA20_68 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 68;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_56 >= 0x0000) && (LA20_56 <= '\'')) || ((LA20_56 >= ',') && (LA20_56 <= '>')) || ((LA20_56 >= '@') && (LA20_56 <= 'd')) || ((LA20_56 >= 'f') && (LA20_56 <= 'z')) || ((LA20_56 >= '~') && (LA20_56 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 56;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_44 >= 0x0000) && (LA20_44 <= '\'')) || ((LA20_44 >= ',') && (LA20_44 <= '>')) || ((LA20_44 >= '@') && (LA20_44 <= 'v')) || ((LA20_44 >= 'x') && (LA20_44 <= 'z')) || ((LA20_44 >= '~') && (LA20_44 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 44;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_31 >= 0x0000) && (LA20_31 <= '\'')) || ((LA20_31 >= ',') && (LA20_31 <= '>')) || ((LA20_31 >= '@') && (LA20_31 <= 'n')) || ((LA20_31 >= 'p') && (LA20_31 <= 'z')) || ((LA20_31 >= '~') && (LA20_31 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 31;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'p'))
                            {
                                {
                                    int LA20_32 = LA(4);
                                    if ( (LA20_32 == 'r'))
                                    {
                                        {
                                            int LA20_45 = LA(5);
                                            if ( (LA20_45 == 'i'))
                                            {
                                                {
                                                    int LA20_57 = LA(6);
                                                    if ( (LA20_57 == 'n'))
                                                    {
                                                        {
                                                            int LA20_69 = LA(7);
                                                            if ( (LA20_69 == 't'))
                                                            {
                                                                {
                                                                    int LA20_81 = LA(8);
                                                                    if ( (LA20_81 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_93 = LA(9);
                                                                            if ( (LA20_93 == ']'))
                                                                            {
                                                                                alt20=8;
                                                                            }
                                                                            else if ( (((LA20_93 >= 0x0000) && (LA20_93 <= '\'')) || ((LA20_93 >= ',') && (LA20_93 <= '>')) || ((LA20_93 >= '@') && (LA20_93 <= '\\')) || ((LA20_93 >= '^') && (LA20_93 <= 'z')) || ((LA20_93 >= '~') && (LA20_93 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 93;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_81 >= 0x0000) && (LA20_81 <= '\'')) || ((LA20_81 >= ',') && (LA20_81 <= '9')) || ((LA20_81 >= ';') && (LA20_81 <= '>')) || ((LA20_81 >= '@') && (LA20_81 <= 'z')) || ((LA20_81 >= '~') && (LA20_81 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 81;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_69 >= 0x0000) && (LA20_69 <= '\'')) || ((LA20_69 >= ',') && (LA20_69 <= '>')) || ((LA20_69 >= '@') && (LA20_69 <= 's')) || ((LA20_69 >= 'u') && (LA20_69 <= 'z')) || ((LA20_69 >= '~') && (LA20_69 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 69;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_57 >= 0x0000) && (LA20_57 <= '\'')) || ((LA20_57 >= ',') && (LA20_57 <= '>')) || ((LA20_57 >= '@') && (LA20_57 <= 'm')) || ((LA20_57 >= 'o') && (LA20_57 <= 'z')) || ((LA20_57 >= '~') && (LA20_57 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 57;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_45 >= 0x0000) && (LA20_45 <= '\'')) || ((LA20_45 >= ',') && (LA20_45 <= '>')) || ((LA20_45 >= '@') && (LA20_45 <= 'h')) || ((LA20_45 >= 'j') && (LA20_45 <= 'z')) || ((LA20_45 >= '~') && (LA20_45 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 45;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (LA20_32 == 'u'))
                                    {
                                        {
                                            int LA20_46 = LA(5);
                                            if ( (LA20_46 == 'n'))
                                            {
                                                {
                                                    int LA20_58 = LA(6);
                                                    if ( (LA20_58 == 'c'))
                                                    {
                                                        {
                                                            int LA20_70 = LA(7);
                                                            if ( (LA20_70 == 't'))
                                                            {
                                                                {
                                                                    int LA20_82 = LA(8);
                                                                    if ( (LA20_82 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_94 = LA(9);
                                                                            if ( (LA20_94 == ']'))
                                                                            {
                                                                                alt20=9;
                                                                            }
                                                                            else if ( (((LA20_94 >= 0x0000) && (LA20_94 <= '\'')) || ((LA20_94 >= ',') && (LA20_94 <= '>')) || ((LA20_94 >= '@') && (LA20_94 <= '\\')) || ((LA20_94 >= '^') && (LA20_94 <= 'z')) || ((LA20_94 >= '~') && (LA20_94 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 94;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_82 >= 0x0000) && (LA20_82 <= '\'')) || ((LA20_82 >= ',') && (LA20_82 <= '9')) || ((LA20_82 >= ';') && (LA20_82 <= '>')) || ((LA20_82 >= '@') && (LA20_82 <= 'z')) || ((LA20_82 >= '~') && (LA20_82 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 82;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_70 >= 0x0000) && (LA20_70 <= '\'')) || ((LA20_70 >= ',') && (LA20_70 <= '>')) || ((LA20_70 >= '@') && (LA20_70 <= 's')) || ((LA20_70 >= 'u') && (LA20_70 <= 'z')) || ((LA20_70 >= '~') && (LA20_70 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 70;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_58 >= 0x0000) && (LA20_58 <= '\'')) || ((LA20_58 >= ',') && (LA20_58 <= '>')) || ((LA20_58 >= '@') && (LA20_58 <= 'b')) || ((LA20_58 >= 'd') && (LA20_58 <= 'z')) || ((LA20_58 >= '~') && (LA20_58 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 58;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_46 >= 0x0000) && (LA20_46 <= '\'')) || ((LA20_46 >= ',') && (LA20_46 <= '>')) || ((LA20_46 >= '@') && (LA20_46 <= 'm')) || ((LA20_46 >= 'o') && (LA20_46 <= 'z')) || ((LA20_46 >= '~') && (LA20_46 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 46;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_32 >= 0x0000) && (LA20_32 <= '\'')) || ((LA20_32 >= ',') && (LA20_32 <= '>')) || ((LA20_32 >= '@') && (LA20_32 <= 'q')) || ((LA20_32 >= 's') && (LA20_32 <= 't')) || ((LA20_32 >= 'v') && (LA20_32 <= 'z')) || ((LA20_32 >= '~') && (LA20_32 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 32;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 's'))
                            {
                                {
                                    int LA20_33 = LA(4);
                                    if ( (LA20_33 == 'p'))
                                    {
                                        {
                                            int LA20_47 = LA(5);
                                            if ( (LA20_47 == 'a'))
                                            {
                                                {
                                                    int LA20_59 = LA(6);
                                                    if ( (LA20_59 == 'c'))
                                                    {
                                                        {
                                                            int LA20_71 = LA(7);
                                                            if ( (LA20_71 == 'e'))
                                                            {
                                                                {
                                                                    int LA20_83 = LA(8);
                                                                    if ( (LA20_83 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_95 = LA(9);
                                                                            if ( (LA20_95 == ']'))
                                                                            {
                                                                                alt20=10;
                                                                            }
                                                                            else if ( (((LA20_95 >= 0x0000) && (LA20_95 <= '\'')) || ((LA20_95 >= ',') && (LA20_95 <= '>')) || ((LA20_95 >= '@') && (LA20_95 <= '\\')) || ((LA20_95 >= '^') && (LA20_95 <= 'z')) || ((LA20_95 >= '~') && (LA20_95 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 95;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_83 >= 0x0000) && (LA20_83 <= '\'')) || ((LA20_83 >= ',') && (LA20_83 <= '9')) || ((LA20_83 >= ';') && (LA20_83 <= '>')) || ((LA20_83 >= '@') && (LA20_83 <= 'z')) || ((LA20_83 >= '~') && (LA20_83 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 83;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_71 >= 0x0000) && (LA20_71 <= '\'')) || ((LA20_71 >= ',') && (LA20_71 <= '>')) || ((LA20_71 >= '@') && (LA20_71 <= 'd')) || ((LA20_71 >= 'f') && (LA20_71 <= 'z')) || ((LA20_71 >= '~') && (LA20_71 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 71;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_59 >= 0x0000) && (LA20_59 <= '\'')) || ((LA20_59 >= ',') && (LA20_59 <= '>')) || ((LA20_59 >= '@') && (LA20_59 <= 'b')) || ((LA20_59 >= 'd') && (LA20_59 <= 'z')) || ((LA20_59 >= '~') && (LA20_59 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 59;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_47 >= 0x0000) && (LA20_47 <= '\'')) || ((LA20_47 >= ',') && (LA20_47 <= '>')) || ((LA20_47 >= '@') && (LA20_47 <= '`')) || ((LA20_47 >= 'b') && (LA20_47 <= 'z')) || ((LA20_47 >= '~') && (LA20_47 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 47;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_33 >= 0x0000) && (LA20_33 <= '\'')) || ((LA20_33 >= ',') && (LA20_33 <= '>')) || ((LA20_33 >= '@') && (LA20_33 <= 'o')) || ((LA20_33 >= 'q') && (LA20_33 <= 'z')) || ((LA20_33 >= '~') && (LA20_33 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 33;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'u'))
                            {
                                {
                                    int LA20_34 = LA(4);
                                    if ( (LA20_34 == 'p'))
                                    {
                                        {
                                            int LA20_48 = LA(5);
                                            if ( (LA20_48 == 'p'))
                                            {
                                                {
                                                    int LA20_60 = LA(6);
                                                    if ( (LA20_60 == 'e'))
                                                    {
                                                        {
                                                            int LA20_72 = LA(7);
                                                            if ( (LA20_72 == 'r'))
                                                            {
                                                                {
                                                                    int LA20_84 = LA(8);
                                                                    if ( (LA20_84 == ':'))
                                                                    {
                                                                        {
                                                                            int LA20_96 = LA(9);
                                                                            if ( (LA20_96 == ']'))
                                                                            {
                                                                                alt20=11;
                                                                            }
                                                                            else if ( (((LA20_96 >= 0x0000) && (LA20_96 <= '\'')) || ((LA20_96 >= ',') && (LA20_96 <= '>')) || ((LA20_96 >= '@') && (LA20_96 <= '\\')) || ((LA20_96 >= '^') && (LA20_96 <= 'z')) || ((LA20_96 >= '~') && (LA20_96 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 96;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_84 >= 0x0000) && (LA20_84 <= '\'')) || ((LA20_84 >= ',') && (LA20_84 <= '9')) || ((LA20_84 >= ';') && (LA20_84 <= '>')) || ((LA20_84 >= '@') && (LA20_84 <= 'z')) || ((LA20_84 >= '~') && (LA20_84 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 84;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_72 >= 0x0000) && (LA20_72 <= '\'')) || ((LA20_72 >= ',') && (LA20_72 <= '>')) || ((LA20_72 >= '@') && (LA20_72 <= 'q')) || ((LA20_72 >= 's') && (LA20_72 <= 'z')) || ((LA20_72 >= '~') && (LA20_72 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 72;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_60 >= 0x0000) && (LA20_60 <= '\'')) || ((LA20_60 >= ',') && (LA20_60 <= '>')) || ((LA20_60 >= '@') && (LA20_60 <= 'd')) || ((LA20_60 >= 'f') && (LA20_60 <= 'z')) || ((LA20_60 >= '~') && (LA20_60 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 60;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_48 >= 0x0000) && (LA20_48 <= '\'')) || ((LA20_48 >= ',') && (LA20_48 <= '>')) || ((LA20_48 >= '@') && (LA20_48 <= 'o')) || ((LA20_48 >= 'q') && (LA20_48 <= 'z')) || ((LA20_48 >= '~') && (LA20_48 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 48;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_34 >= 0x0000) && (LA20_34 <= '\'')) || ((LA20_34 >= ',') && (LA20_34 <= '>')) || ((LA20_34 >= '@') && (LA20_34 <= 'o')) || ((LA20_34 >= 'q') && (LA20_34 <= 'z')) || ((LA20_34 >= '~') && (LA20_34 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 34;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (LA20_15 == 'x'))
                            {
                                {
                                    int LA20_35 = LA(4);
                                    if ( (LA20_35 == 'd'))
                                    {
                                        {
                                            int LA20_49 = LA(5);
                                            if ( (LA20_49 == 'i'))
                                            {
                                                {
                                                    int LA20_61 = LA(6);
                                                    if ( (LA20_61 == 'g'))
                                                    {
                                                        {
                                                            int LA20_73 = LA(7);
                                                            if ( (LA20_73 == 'i'))
                                                            {
                                                                {
                                                                    int LA20_85 = LA(8);
                                                                    if ( (LA20_85 == 't'))
                                                                    {
                                                                        {
                                                                            int LA20_97 = LA(9);
                                                                            if ( (LA20_97 == ':'))
                                                                            {
                                                                                {
                                                                                    int LA20_109 = LA(10);
                                                                                    if ( (LA20_109 == ']'))
                                                                                    {
                                                                                        alt20=12;
                                                                                    }
                                                                                    else if ( (((LA20_109 >= 0x0000) && (LA20_109 <= '\'')) || ((LA20_109 >= ',') && (LA20_109 <= '>')) || ((LA20_109 >= '@') && (LA20_109 <= '\\')) || ((LA20_109 >= '^') && (LA20_109 <= 'z')) || ((LA20_109 >= '~') && (LA20_109 <= 0xFFFE))))
                                                                                    {
                                                                                        alt20=32;
                                                                                    }
                                                                                    else
                                                                                    {

                                                                                        CONSTRUCTEX();
                                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                        EXCEPTION->message      = (void *)"";
                                                                                        EXCEPTION->decisionNum  = 20;
                                                                                        EXCEPTION->state        = 109;


                                                                                        goto ruleTokensEx;

                                                                                    }
                                                                                }
                                                                            }
                                                                            else if ( (((LA20_97 >= 0x0000) && (LA20_97 <= '\'')) || ((LA20_97 >= ',') && (LA20_97 <= '9')) || ((LA20_97 >= ';') && (LA20_97 <= '>')) || ((LA20_97 >= '@') && (LA20_97 <= 'z')) || ((LA20_97 >= '~') && (LA20_97 <= 0xFFFE))))
                                                                            {
                                                                                alt20=32;
                                                                            }
                                                                            else
                                                                            {

                                                                                CONSTRUCTEX();
                                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                                EXCEPTION->message      = (void *)"";
                                                                                EXCEPTION->decisionNum  = 20;
                                                                                EXCEPTION->state        = 97;


                                                                                goto ruleTokensEx;

                                                                            }
                                                                        }
                                                                    }
                                                                    else if ( (((LA20_85 >= 0x0000) && (LA20_85 <= '\'')) || ((LA20_85 >= ',') && (LA20_85 <= '>')) || ((LA20_85 >= '@') && (LA20_85 <= 's')) || ((LA20_85 >= 'u') && (LA20_85 <= 'z')) || ((LA20_85 >= '~') && (LA20_85 <= 0xFFFE))))
                                                                    {
                                                                        alt20=32;
                                                                    }
                                                                    else
                                                                    {

                                                                        CONSTRUCTEX();
                                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                        EXCEPTION->message      = (void *)"";
                                                                        EXCEPTION->decisionNum  = 20;
                                                                        EXCEPTION->state        = 85;


                                                                        goto ruleTokensEx;

                                                                    }
                                                                }
                                                            }
                                                            else if ( (((LA20_73 >= 0x0000) && (LA20_73 <= '\'')) || ((LA20_73 >= ',') && (LA20_73 <= '>')) || ((LA20_73 >= '@') && (LA20_73 <= 'h')) || ((LA20_73 >= 'j') && (LA20_73 <= 'z')) || ((LA20_73 >= '~') && (LA20_73 <= 0xFFFE))))
                                                            {
                                                                alt20=32;
                                                            }
                                                            else
                                                            {

                                                                CONSTRUCTEX();
                                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                                EXCEPTION->message      = (void *)"";
                                                                EXCEPTION->decisionNum  = 20;
                                                                EXCEPTION->state        = 73;


                                                                goto ruleTokensEx;

                                                            }
                                                        }
                                                    }
                                                    else if ( (((LA20_61 >= 0x0000) && (LA20_61 <= '\'')) || ((LA20_61 >= ',') && (LA20_61 <= '>')) || ((LA20_61 >= '@') && (LA20_61 <= 'f')) || ((LA20_61 >= 'h') && (LA20_61 <= 'z')) || ((LA20_61 >= '~') && (LA20_61 <= 0xFFFE))))
                                                    {
                                                        alt20=32;
                                                    }
                                                    else
                                                    {

                                                        CONSTRUCTEX();
                                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                        EXCEPTION->message      = (void *)"";
                                                        EXCEPTION->decisionNum  = 20;
                                                        EXCEPTION->state        = 61;


                                                        goto ruleTokensEx;

                                                    }
                                                }
                                            }
                                            else if ( (((LA20_49 >= 0x0000) && (LA20_49 <= '\'')) || ((LA20_49 >= ',') && (LA20_49 <= '>')) || ((LA20_49 >= '@') && (LA20_49 <= 'h')) || ((LA20_49 >= 'j') && (LA20_49 <= 'z')) || ((LA20_49 >= '~') && (LA20_49 <= 0xFFFE))))
                                            {
                                                alt20=32;
                                            }
                                            else
                                            {

                                                CONSTRUCTEX();
                                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                                EXCEPTION->message      = (void *)"";
                                                EXCEPTION->decisionNum  = 20;
                                                EXCEPTION->state        = 49;


                                                goto ruleTokensEx;

                                            }
                                        }
                                    }
                                    else if ( (((LA20_35 >= 0x0000) && (LA20_35 <= '\'')) || ((LA20_35 >= ',') && (LA20_35 <= '>')) || ((LA20_35 >= '@') && (LA20_35 <= 'c')) || ((LA20_35 >= 'e') && (LA20_35 <= 'z')) || ((LA20_35 >= '~') && (LA20_35 <= 0xFFFE))))
                                    {
                                        alt20=32;
                                    }
                                    else
                                    {

                                        CONSTRUCTEX();
                                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                        EXCEPTION->message      = (void *)"";
                                        EXCEPTION->decisionNum  = 20;
                                        EXCEPTION->state        = 35;


                                        goto ruleTokensEx;

                                    }
                                }
                            }
                            else if ( (((LA20_15 >= 0x0000) && (LA20_15 <= '\'')) || ((LA20_15 >= ',') && (LA20_15 <= '>')) || ((LA20_15 >= '@') && (LA20_15 <= '`')) || ((LA20_15 >= 'e') && (LA20_15 <= 'f')) || ((LA20_15 >= 'h') && (LA20_15 <= 'k')) || ((LA20_15 >= 'm') && (LA20_15 <= 'o')) || ((LA20_15 >= 'q') && (LA20_15 <= 'r')) || LA20_15 == 't' || ((LA20_15 >= 'v') && (LA20_15 <= 'w')) || ((LA20_15 >= 'y') && (LA20_15 <= 'z')) || ((LA20_15 >= '~') && (LA20_15 <= 0xFFFE))))
                            {
                                alt20=32;
                            }
                            else
                            {

                                CONSTRUCTEX();
                                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                                EXCEPTION->message      = (void *)"";
                                EXCEPTION->decisionNum  = 20;
                                EXCEPTION->state        = 15;


                                goto ruleTokensEx;

                            }
                        }
                    }
                    else if ( (((LA20_1 >= 0x0000) && (LA20_1 <= '\'')) || ((LA20_1 >= ',') && (LA20_1 <= '9')) || ((LA20_1 >= ';') && (LA20_1 <= '>')) || ((LA20_1 >= '@') && (LA20_1 <= '\\')) || ((LA20_1 >= '^') && (LA20_1 <= 'z')) || ((LA20_1 >= '~') && (LA20_1 <= 0xFFFE))))
                    {
                        alt20=32;
                    }
                    else
                    {
                        alt20=16;
                    }
                }
            }
            else if ( (((LA20_0 >= '\t') && (LA20_0 <= '\n')) || LA20_0 == '\r' || LA20_0 == ' '))
            {
                alt20=13;
            }
            else if ( (LA20_0 == '('))
            {
                alt20=14;
            }
            else if ( (LA20_0 == ')'))
            {
                alt20=15;
            }
            else if ( (LA20_0 == ']'))
            {
                alt20=17;
            }
            else if ( (LA20_0 == '{'))
            {
                switch ( LA(2) )
                {
                case ',':
                case '0':
                	{
                		alt20=25;
                	}
                    break;
                case '1':
                	{
                		switch ( LA(3) )
                		{
                		case ',':
                		case '}':
                			{
                				alt20=26;
                			}
                		    break;
                		case '0':
                		case '1':
                		case '2':
                		case '3':
                		case '4':
                		case '5':
                		case '6':
                		case '7':
                		case '8':
                		case '9':
                			{
                				alt20=27;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 20;
                		    EXCEPTION->state        = 20;


                		    goto ruleTokensEx;

                		}

                	}
                    break;
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                	{
                		alt20=27;
                	}
                    break;

                default:
                    alt20=18;
                }

            }
            else if ( (LA20_0 == '}'))
            {
                alt20=19;
            }
            else if ( (LA20_0 == '|'))
            {
                alt20=20;
            }
            else if ( (LA20_0 == '*'))
            {
                alt20=21;
            }
            else if ( (LA20_0 == '+'))
            {
                alt20=22;
            }
            else if ( (LA20_0 == '?'))
            {
                alt20=23;
            }
            else if ( (LA20_0 == '.'))
            {
                alt20=24;
            }
            else if ( (LA20_0 == '\\'))
            {
                {
                    int LA20_13 = LA(2);
                    if ( (LA20_13 == '$' || ((LA20_13 >= '(') && (LA20_13 <= '+')) || LA20_13 == '.' || LA20_13 == '?' || ((LA20_13 >= '[') && (LA20_13 <= '^')) || ((LA20_13 >= '{') && (LA20_13 <= '}'))))
                    {
                        alt20=28;
                    }
                    else if ( (((LA20_13 >= '0') && (LA20_13 <= '9'))))
                    {
                        alt20=29;
                    }
                    else if ( (((LA20_13 >= 0x0000) && (LA20_13 <= '#')) || ((LA20_13 >= '%') && (LA20_13 <= '\'')) || ((LA20_13 >= ',') && (LA20_13 <= '-')) || LA20_13 == '/' || ((LA20_13 >= ':') && (LA20_13 <= '>')) || ((LA20_13 >= '@') && (LA20_13 <= 'Z')) || ((LA20_13 >= '_') && (LA20_13 <= 'z')) || ((LA20_13 >= '~') && (LA20_13 <= 0xFFFF))))
                    {
                        alt20=30;
                    }
                    else
                    {
                        alt20=31;
                    }
                }
            }
            else if ( (((LA20_0 >= 0x0000) && (LA20_0 <= '\b')) || ((LA20_0 >= 0x000B) && (LA20_0 <= '\f')) || ((LA20_0 >= 0x000E) && (LA20_0 <= 0x001F)) || ((LA20_0 >= '!') && (LA20_0 <= '\'')) || ((LA20_0 >= ',') && (LA20_0 <= '-')) || ((LA20_0 >= '/') && (LA20_0 <= '>')) || ((LA20_0 >= '@') && (LA20_0 <= 'Z')) || ((LA20_0 >= '^') && (LA20_0 <= 'z')) || ((LA20_0 >= '~') && (LA20_0 <= 0xFFFE))))
            {
                alt20=31;
            }
            else
            {

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleTokensEx;

            }
        }
        switch (alt20)
        {
    	case 1:
    	    // regexopt.g:1:10: ALNUM
    	    {
    	        /* 1:10: ALNUM */
    	        mALNUM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // regexopt.g:1:16: ALPHA
    	    {
    	        /* 1:16: ALPHA */
    	        mALPHA(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // regexopt.g:1:22: BLANK
    	    {
    	        /* 1:22: BLANK */
    	        mBLANK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // regexopt.g:1:28: CNTRL
    	    {
    	        /* 1:28: CNTRL */
    	        mCNTRL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // regexopt.g:1:34: DIGIT
    	    {
    	        /* 1:34: DIGIT */
    	        mDIGIT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // regexopt.g:1:40: GRAPH
    	    {
    	        /* 1:40: GRAPH */
    	        mGRAPH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // regexopt.g:1:46: LOWER
    	    {
    	        /* 1:46: LOWER */
    	        mLOWER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // regexopt.g:1:52: PRINT
    	    {
    	        /* 1:52: PRINT */
    	        mPRINT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // regexopt.g:1:58: PUNCT
    	    {
    	        /* 1:58: PUNCT */
    	        mPUNCT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // regexopt.g:1:64: SPACE
    	    {
    	        /* 1:64: SPACE */
    	        mSPACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // regexopt.g:1:70: UPPER
    	    {
    	        /* 1:70: UPPER */
    	        mUPPER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // regexopt.g:1:76: XDIGIT
    	    {
    	        /* 1:76: XDIGIT */
    	        mXDIGIT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // regexopt.g:1:83: WS_
    	    {
    	        /* 1:83: WS_ */
    	        mWS_(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // regexopt.g:1:87: LPAREN
    	    {
    	        /* 1:87: LPAREN */
    	        mLPAREN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // regexopt.g:1:94: RPAREN
    	    {
    	        /* 1:94: RPAREN */
    	        mRPAREN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // regexopt.g:1:101: LBRACKET
    	    {
    	        /* 1:101: LBRACKET */
    	        mLBRACKET(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // regexopt.g:1:110: RBRACKET
    	    {
    	        /* 1:110: RBRACKET */
    	        mRBRACKET(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // regexopt.g:1:119: LBRACE
    	    {
    	        /* 1:119: LBRACE */
    	        mLBRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // regexopt.g:1:126: RBRACE
    	    {
    	        /* 1:126: RBRACE */
    	        mRBRACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // regexopt.g:1:133: BINOR
    	    {
    	        /* 1:133: BINOR */
    	        mBINOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // regexopt.g:1:139: STAR
    	    {
    	        /* 1:139: STAR */
    	        mSTAR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // regexopt.g:1:144: PLUS
    	    {
    	        /* 1:144: PLUS */
    	        mPLUS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // regexopt.g:1:149: QUEST
    	    {
    	        /* 1:149: QUEST */
    	        mQUEST(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // regexopt.g:1:155: DOT
    	    {
    	        /* 1:155: DOT */
    	        mDOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // regexopt.g:1:159: ZEROANDMORE
    	    {
    	        /* 1:159: ZEROANDMORE */
    	        mZEROANDMORE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // regexopt.g:1:171: ONEANDMORE
    	    {
    	        /* 1:171: ONEANDMORE */
    	        mONEANDMORE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // regexopt.g:1:182: TWOANDMORE
    	    {
    	        /* 1:182: TWOANDMORE */
    	        mTWOANDMORE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // regexopt.g:1:193: ESC
    	    {
    	        /* 1:193: ESC */
    	        mESC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // regexopt.g:1:197: BACKREF
    	    {
    	        /* 1:197: BACKREF */
    	        mBACKREF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // regexopt.g:1:205: SPECIAL
    	    {
    	        /* 1:205: SPECIAL */
    	        mSPECIAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // regexopt.g:1:213: NOMETA
    	    {
    	        /* 1:213: NOMETA */
    	        mNOMETA(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // regexopt.g:1:220: ENUM
    	    {
    	        /* 1:220: ENUM */
    	        mENUM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
